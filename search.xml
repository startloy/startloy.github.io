<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组处理不常用函数]]></title>
    <url>%2F2018%2F%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PHP CURL]]></title>
    <url>%2F2018%2FPHP-CURL%2F</url>
    <content type="text"><![CDATA[1234近期项目中需要和客户对接接口，接口中需要添加header头信息进行安全验证。然后就是无情翻车，最后查到原因是 PHP中 md5() 函数出来的加密序列默认是32位，md5($sign, true); 第二参数设置为 true 时会返回16位加密序列，但是16位加密序列包含不可显示字符，无法验证通过。（这里标识下，通过网站上面进行md5获得的16位的加密序列实际上是32序列截取中间16位之后的结果。） 这里贴上 php curl 封装的 post 和 get 请求，之前用https竟然死活请求不成功，更换为http才能行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function req_post($url = '', $param = '') &#123; if (empty($url) || empty($param)) &#123; return false; &#125; $appkey = '*******'; $appsecret = '****************************'; $timespan = time(); $guid = rand(1000,9999); $platform = 'sign'; $sign = $appkey.'|'.$timespan.'|'.$guid.'|'.$platform.'|'.$appsecret; $sign = strtoupper(md5($sign, false)); $postUrl = $url; $curlPost = $param; $ch = curl_init();//初始化curl curl_setopt($ch, CURLOPT_URL,$postUrl);//抓取指定网页 // curl_setopt($ch, CURLOPT_HEADER, 0);//设置header $header = ['platform:sign','timespan:'.$timespan,'guid:'.$guid,'sign:'.$sign]; //设置一个你的浏览器agent的header curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);// 要求结果为字符串且输出到屏幕上 curl_setopt($ch, CURLOPT_POST, 1);//post提交方式 curl_setopt($ch, CURLOPT_POSTFIELDS, $curlPost); $data = curl_exec($ch);//运行curl curl_close($ch); return $data; &#125;function get1($url) &#123; $appkey = '********'; $appsecret = '*******************'; $timespan = time(); $guid = rand(1000,9999); $platform = 'sign'; $sign = $appkey.'|'.$timespan.'|'.$guid.'|'.$platform.'|'.$appsecret; $sign = strtoupper(md5($sign, false)); $ch = curl_init(); curl_setopt($ch, CURLOPT_HTTPGET, true); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //TRUE 将curl_exec()获取的信息以字符串返回，而不是直接输出。 // $header = ['User-Agent: php test']; //设置一个你的浏览器agent的header $header = ['platform:sign','timespan:'.$timespan,'guid:'.$guid,'sign:'.$sign]; //设置一个你的浏览器agent的header curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_HEADER, 0); //返回response头部信息 curl_setopt($ch, CURLINFO_HEADER_OUT, true); //TRUE 时追踪句柄的请求字符串，从 PHP 5.1.3 开始可用。这个很关键，就是允许你查看请求header curl_setopt($ch, CURLOPT_URL, $url); $result = json_decode(curl_exec($ch), true); // echo curl_getinfo($ch, CURLINFO_HEADER_OUT); //官方文档描述是“发送请求的字符串”，其实就是请求的header。这个就是直接查看请求header，因为上面允许查看 curl_close($ch); return $result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python学习之Turtle]]></title>
    <url>%2F2018%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8BTurtle%2F</url>
    <content type="text"><![CDATA[第一次接触 Python 时是看小甲鱼的课程(哈哈~算是打个广告吧)“打飞机”游戏，之后因为零零碎碎的原因(其实就是懒= 。=)，学习总是断断续续的。Python 在图像处理这块确实比PHP要厉害。在博客中记录下 学习过程，防止过后又忘（不常用肯定会忘的啊）！ 123还有一点感悟就是，再看一些教程的时候总是很浮躁，固然能实现一些示例，但是往往会忽视一些比较基础的语法和概念。写代码的时候很少能感受出来，因为很多时候都是念着尽快实现功能，不会去想会不会有更好的实现方式，而更好的实现方式实际上是离不开对一门语言进行透彻的理解的。所以在时间不是特别紧的时候，一定要注意一些基础的东西。 12345678Python 33 个保留字 and elif import raise global as else in return nonlocal assert except is try ture break finally lambda while False class for not with None continue from or yield def if pass del Python 基础数据类型处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697浮点数类型的运算存在不确定尾数，不是Bug 0.1 + 0.2 不等于 0.3 原因 0.1 在机器语言中用 53位二进制表示小数部分， 约 10 的 负16次方 二进制 和 十进制 不是完全对等的关系 二进制表示小数可以无限接近10进制的小数，但不完全相同。 在浮点数间运算及比较用round()函数辅助浮点数可以采用科学计数法表示 使用字母 e 或 E 作为幂的符号，以10为基数，格式如下 &lt;a&gt;e&lt;b&gt; 表示 a*10的b次方复数类型 与数学中复数的概念一致 定义 j = 根号 (-1) ，以此为基础，构建数学体系 a+bj 被称为复数 ， 其中 a 是实部，b 是虚部。 z = 1.23e-4 + 5.6e + 89j z.real 获取实部 z.imag 获取虚部 x/y // 两数相除 获取浮点数结果 x//y // 整数除，x 与 y 之商 10//3 == 3 x%y // 余数，模运算 10%3 == 1 x**y // 幂运算，x 的 y 次幂，当 y 是小数时，进行开方运算，10**0.5 结果是 根号10数值运算函数 abs(x) // 获取 x 的绝对值 divmod(x, y) // 商余，同时输出 商 和 余数 pow(x, y [,z]) // (x**y)%z , [,z] 表示参数 z 可省略。 pow(3, pow(3, 99), 10000); // 结果为 4587 ，不求余的话 一半计算机是无法计算出这么大的数值的 round(x, d) // 对 x 进行四舍五入，d 是小数截取位数。 max(x1, x2 ... xn) // 获取最大值 min(x1, x2 ... xn) // 获取最小值 int(x) // 将 x 变成整数，舍弃小数部分 float(x) // 将 x 变成浮点数，增加小数部分 complex(x) // 将 x 变成复数，增加其虚数部分。 i%7 in [6,0] // 365 天休息日字符串处理函数 以 三个单引号 ''' 表示的字符 若没有赋值给任何变量 可以被作为注释使用 将一段字符逆序排列 '123456'[::-1] 3*'nn' 或 'nn'*3 // 将 nn 字符串 连续输出3次 字符串拼接 使用+ len(x) // 返回字符串长度 set(x) // 返回任意类型 x 对应的字符串形式 hex(x) 或 oct(x) 整数 x 的十六进制或八进制小写形式字符串 chr(x) // x 为Unicode编码 , 返回其对应的字符 ord(x) // x 为字符 , 返回其对应的Unicode编码 Python 的字符编码嗾使 Unicode编码 // chr(10004) -&gt; 输出 对勾 chr(9800) // 输出白羊座的图标 循环输出 12 星座图标 for i in range(12): a = 9800+i; print(chr(a),end = '\n\r');字符串处理方法 str.lower() 或 str.supper() // 返回字符串的副本,全部字符小写/大写 str.split(sep=None) // 返回有 sep 分割的 str 之后组成的数组 str.count(sup) // 计算 su 在str中出现的次数 str.replace(old, new) // 发返回字符串str副本,所有old子字符串被替换为new. str.center(width[,fillchar]) // 字符串 str 根据宽度居中,width为要输出的字符宽度, fillchar为居中后字符两侧需填充的内容. str.strip(chars) // 从 str 中去掉左侧和由此char中列出的所有字符 区分大小写 "= Python=".strip(" =np") str.join(iter) // 将字符 iter 中的每个元素后增加一个 str ",".join("1234") // 主要用于分割字符字符类型的格式化 &lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;) "&#123;1&#125;:计算机&#123;0&#125;的CPU占用率&#123;2&#125;%".format("2018-10-10", "C", "10"); &#123;&#125; 表示槽 , 槽中的参数序号 和 format 中参数一一对应 槽内部对格式化的配置方式 &#123;&lt;参数序号&gt; : &lt;格式控制标记&gt;&#125; 格式控制标记 : 引导符号 &lt;填充&gt; &lt;对齐&gt; &gt; 右对齐 &lt; 左对齐 ^ 居中对齐 &lt;宽度&gt; 槽设定的输出宽度 &lt; , &gt; 数字的千位分隔符 &lt;.精度&gt; 浮点数小数精度 或 字符串最大的输出长度 &lt;类型&gt; 整数类型 b,c,d,o,x,X ;浮点数类型 e,E,f,% "&#123;0:=^20&#125;".format("Python"); "&#123;0:,.2f&#125;".format(123456.444); "&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;".format(425); "&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;".format(425); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556程序的异常处理 try : &lt;语句块1&gt; except [&lt;异常类型&gt;]: // 在设置异常类型之后，try 语句块 只能响应设置后的异常类型 &lt;语句块2&gt;程序异常高级处理 try : &lt;语句块1&gt; except : &lt;语句块2&gt; else : &lt;语句块3&gt; finally : &lt;语句块4&gt; finally 所对应 语句块4 一定执行 else 所对应 语句块3 在不发生异常时执行 注意一个 break 关键字 只能跳出一层循环。循环 与 else 在循环语句 正常退出(不是通过 break 或 continue 退出)时 可以触发 else 中语句块 for c in "PYTHON" : if c == "T" : continue print(c, end="") else: print("正常退出") for c in "PYTHON": if c == "T": break print(c, end="") else: print("正常退出") 123456紧凑型的二分支结构 // 这里不是语句 而是表达式，是语句的一部分，只有判断没有赋值 &lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt; guess = eval(input()); print("猜&#123;&#125;了".format('对' if guess == 99 else '错')); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576turtle (海龟)库 是 turtle 绘图体系的 Python 实现 turtle 绘图体系诞生于1969年，主要用于程序设计入门 Python 语言的标准库之一 入门级的图形绘制函数库turtle 空间坐标体系 绝对坐标 海龟初始在 画布中心 坐标为 0,0 海龟坐标 有前进方向、后退方向、左侧方向、右侧方向。 fd(d) 表示海龟向 正前方运行 bk(d) 表示海龟向 正后方运行 circle() 表示以海龟当前坐标的左边某一点画圆turtle 角度坐标体系 绝对角度 x 轴正方向 表示 0/360 度 y 轴正方向 表示 90/-270 度 seth(angle) // 只改变海龟的行进方向但不行进 海龟角度 以海龟角度来控制 其行进角度 left(angle) right(angle)turtle 画笔控制函数 画笔操作后一直有效，一般成对出现 turtle.penup() 别名 turtle.pu() // 抬起画笔，海龟在飞行 turtle.pendown() 别名 turtle.pd() // 落下画笔，海龟在爬行 turtle.pensize(width) 别名 turtle.width(width) // 设置画笔宽度 turtle.pencolor(color) 为画笔设置颜色 color 为颜色字符串 或 r,g,b 值 color 的 填写形式有 字符串，多值调用，元组turtle 运动控制函数 turtle.forword(d) 别名 turtle.fd(d) // 向前行进，走直线 d表示行进距离，可为负数 turtle.circle(r, extent=None) 根据半径 r 绘制 extent 角度的弧形 r 默认圆心在海龟左侧 r 距离的位置，值为负数时，表示圆心在海归右侧 extent 绘制角度，默认是 360度 整圆程序最后加上 curcle.done() 函数之后 程序运行完成之后不会自动结束，要手动关闭窗口之后才会结束。 turtle.bgcolor(); // 设置画板背景颜色 t.color('black','black'); // 设置颜色 t.begin_fill(); 填充颜色 t.end_fill();turtle 方向控制函数 turtle.setheading(angle)别名 turtle.seth(angle) // 只改变方向，即海龟行进角度 在海龟视角的转向 turtle.left(angle) turtle.right(angle)turtle 的RGB色彩模式 turtle 默认采用 RGB 小数值来获取颜色 可切换为整数值 turtle.colormode(mode) mode = 1.0 : RGB 为小数值模式 mode = 255 : RGB 为整数值模式 turtle.setup(width, height, startx, starty); // 设置长提的大小和位置 后两个参数可选。 turtle.goto(x, y); // x方向 相对于海龟初始 0,0 坐标 移动 x 单位个像素; y方向 相对于海龟初始 0,0 坐标 移动 Y 单位个像素 turtle.hideturtle(); // 隐藏海龟箭头附加常用函数 turtle.bgcolor("black"); #设置画面背景色 turtle.bye(); #退出turtle，无任何提示信息 turtle.hideturtle(); #隐藏画笔 turtle.showturtle(); #显示画笔 12345678910111213141516171819202122232425262728293031Python 标准库之 Time 库time() 获取当前时间戳，即计算机内部时间值，浮点数ctime() 获取当前时间并以已读方式表示，返回字符串gmtime() 获取当前时间，表示计算机可处理的时间格式时间格式化函数 strftime(tpl, ts) tpl 是格式化模板字符串，用来定义输出效果。 ts 是计算机内部时间类型变量 time.strftime("%Y-%m-%d", time.gmtime()); strptime(str, tpl); str 是 字符串形式的时间值。 tpl 是 格式化模板字符串，用来定义输入效果。 timestr = '2018-01-26 12:10:1'; time.strptime(timestr, "%Y-%m-%d %H:%M:%S"); 这里注意 strptime 函数中两个参数的 精确程度要保持一致。程序计时 perf_counter() 返回一个CPU级别的精确时间计数值，单位为秒，由于这个计数值的起点不确定，连续调用才有意义。 sleep(s); // 使程序停止运行 s 秒， s 可以为浮点数 print(1,end = ''); // print 函数只有一个输出结果时，在输出完成之后默认换行。但是手动设置非首个参数的值之后，系统就会取消默认换行。 IDLE中屏蔽了 \r 功能 单行动态刷新无法实现。 文本进度条展示函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657这里是用 Turtle 实现的时间数码管。# 数码管绘制时间import turtle as tt.setup(800,300,200,200);t.pu();t.bk(300);t.pd();t.pencolor('pink');def drawline(draw): t.pensize(4) t.pd() if draw else t.pu(); t.fd(25); t.pu(); t.fd(5); t.right(90); t.fd(5); t.pd(); return;def drawdigit(x): drawline(1) if x in [2,3,4,5,6,8,9] else drawline(0); drawline(1) if x in [1,3,4,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [2,3,5,6,8,0] else drawline(0); drawline(1) if x in [2,6,8,0] else drawline(0); t.pu(); t.bk(5); t.left(90); t.fd(5); t.pd(); drawline(1) if x in [4,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [2,3,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [1,2,3,4,7,8,9,0] else drawline(0); t.pu(); t.left(180); t.fd(10); t.pd(); return;def main(date = '20180612'): for index,i in enumerate(date): drawdigit(eval(i)); t.pu(); if index in [3,5]: t.fd(55); else : t.fd(10); t.pd(); return;main();t.hideturtle(); 其实还画了几个小时出来了一个小猪佩奇 但是因为没有封装函数，代码冗余是在是过分（好意思说？？？）就先不放源码了。嘿嘿~ 效果图来一张，源码整理之后再放]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP_GD 图片合成]]></title>
    <url>%2F2018%2FPHP-GD-%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是 将切圆的微信头像、个人属性二维码、文字信息 合成到一张图片上传到前端进行显示。毕竟也是花了点时间做出来的东西，就在这里记录下吧 废话不说直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263&lt;?php$url_pic = "http://xxxxxx.bxxxn.xx/zxxx/getPic.php"; # 这里是通过自己的接口获取事先存在数据库中的微信头像地址$info_header = json_decode(https_request($url_pic,$data_info));$url_header = $info_header-&gt;msg;function yuan_img($imgpath = 'Logo.jpg') &#123; $src_img = null; $a = getimagesize($imgpath); switch ($a[2]) &#123; case 1: $src_img = imagecreatefromgif($imgpath); break; case 2: $src_img = imagecreatefromjpeg($imgpath); break; case 3: $src_img = imagecreatefrompng($imgpath); break; default: echo '图片格式不正确'; break; &#125; $wh = getimagesize($imgpath); $w = $wh[0]; $h = $wh[1]; $w = min($w, $h); $h = $w; $img = imagecreatetruecolor($w, $h); //这一句一定要有 imagesavealpha($img, true); //拾取一个完全透明的颜色,最后一个参数127为全透明 $bg = imagecolorallocatealpha($img, 255, 255, 255, 127); imagefill($img, 0, 0, $bg); $r = $w / 2; //圆半径 $y_x = $r; //圆心X坐标 $y_y = $r; //圆心Y坐标 for ($x = 0; $x &lt; $w; $x++) &#123; for ($y = 0; $y &lt; $h; $y++) &#123; $rgbColor = imagecolorat($src_img, $x, $y); if (((($x - $r) * ($x - $r) + ($y - $r) * ($y - $r)) &lt; ($r * $r))) &#123; imagesetpixel($img, $x, $y, $rgbColor); &#125; &#125; &#125; return $img;&#125;// 创建目录function createfolder($destFd) &#123; $year = date('Y'); $month = date('m'); $day = date('d'); $dirroot = dirname(__FILE__); $folder = $dirroot . "/" . $destFd . $year . "/" . $month . "/" . $day . "/"; if (! is_dir($folder)) &#123; mkdir($folder, 0777, true); &#125; return $folder; &#125;// 下载微信头像 微信头像的格式为 jpeg 最好写判断function download_img($url = "", $filename = "")&#123; $ch = curl_init(); //初始化一个curl句柄 $hd = fopen($filename,'wb'); //只写打开或新建一个二进制文件；只允许写数据 curl_setopt($ch,CURLOPT_URL,$url); //需要获取的 URL 地址 curl_setopt($ch,CURLOPT_FILE,$hd); //设置成资源流的形式 curl_setopt($ch,CURLOPT_HEADER,0); //启用时会将头文件的信息作为数据流输出。 //curl_setopt($ch,CURLOPT_RETURNTRANSFER,false);//以数据流的方式返回数据,false时直接显示 curl_setopt($ch,CURLOPT_TIMEOUT,60); //设置超时时间 curl_exec($ch); //执行curl curl_close($ch); //关闭curl会话 fclose($hd); //关闭句柄 return true;&#125;// die('获取微信头像失败');$wx_pic_path = 'Logo.jpg'; # 获取威信头像失败时使用的默认图片if ($url_header != null ) &#123; $path_wx = createfolder('wx_pic'); $picname = $openid.'_WXPIC.png'; $down_wx = download_img($url_header,$path_wx.$picname); if ($down_wx) &#123; $wx_pic_path = $path_wx.$picname; &#125; else &#123; $wx_pic_path = 'Logo.jpg'; &#125;&#125;&lt;!--切圆 Begin 被获取之前变圆形--&gt;$imgg = yuan_img($wx_pic_path);imagepng($imgg,$wx_pic_path);imagedestroy($imgg);&lt;!--切圆 End--&gt;&lt;!--微信 Begin 图片水印--&gt;$logo = $wx_pic_path;$filename = '1.png';// 判断微信头像格式$a = getimagesize($logo);switch ($a[2]) &#123; case 1: $src_im = imagecreatefromgif($logo); break; case 2: $src_im = imagecreatefromjpeg($logo); break; case 3: $src_im = imagecreatefrompng($logo); break; default: echo '图片格式不正确'; break;&#125;// 创建缩略图// 创建画布// $src_im = imagecreatefromjpeg($logo);list($src_w,$src_h) = getimagesize($logo);$min = imagecreatetruecolor(100,100);&lt;!--NB Begin 这里将切圆后的图片背景由黑色变透明色 --&gt;//2.上色$color=imagecolorallocate($min,255,255,255);//3.设置透明imagecolortransparent($min,$color);imagefill($min,0,0,$color);&lt;!--NB End --&gt;imagecopyresampled($min, $src_im, 0, 0, 0, 0, 100, 100, $src_w, $src_h);// 将图片创建为画布资源$dst_im = imagecreatefrompng($filename);list($dst_w,$dst_h) = getimagesize($filename);$dst_x = ($dst_w-100)/2;$dst_y = 180;// 透明度 100 为不透明$pct = 100;list($src_x,$src_y) = getimagesize($logo);imagecopymerge($dst_im, $min, $dst_x, $dst_y, 0, 0, 100, 100, $pct);&lt;!-- 微信 EDN --&gt;&lt;!-- QRCode Begin --&gt;// 通过openid生成专属二维码if ($openid != null) &#123; $url_ip='http://lightup.XXXXX.top/XXXXX.php?openid='.$openid; $ch = curl_init($url_ip); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120); // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); $result = curl_exec($ch); curl_close($ch); $res_qr = json_decode($result); $qr_url = $res_qr-&gt;msg;&#125;// 二维码图片资源list($qr_w,$qr_h) = getimagesize($qr_url);$qr_res = getimagesize($qr_url);switch ($qr_res[2]) &#123; case 1: $qr_mi = imagecreatefromgif($qr_url); break; case 2: $qr_mi = imagecreatefromjpeg($qr_url); break; case 3: $qr_mi = imagecreatefrompng($qr_url); break; default: echo '图片格式不正确';exit; break;&#125;// 缩略 二维码$qr_copy = imagecreatetruecolor(80, 80);imagecopyresampled($qr_copy, $qr_mi, 0, 0, 0, 0, 80, 80, $qr_w, $qr_h);$dst_qr_x = $dst_w-375;$dst_qr_y = 1035;// 透明度 100 为不透明$pct = 100;// 进行 copyimagecopymerge($dst_im, $qr_copy, $dst_qr_x, $dst_qr_y, 0, 0, 80, 80, $pct);&lt;!-- QRCode End --&gt;&lt;!-- 写入文字数据 Begin --&gt;$url_info='http://lightup.XXXX.top/zo_XXX/gXXXXX.php';$data_info = array( 'openid'=&gt;$openid, );function https_request($url, $data = null) &#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE); if (!empty($data))&#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($curl); curl_close($curl); return $output; &#125;// 获取个人信息$info_res = json_decode(https_request($url_info,$data_info));$info_name = $info_res-&gt;msg-&gt;name;$info_score = $info_res-&gt;msg-&gt;score;$info_class = $info_res-&gt;msg-&gt;class;// 姓名水印$nameTextBox = imagettfbbox(18, 0, 'msyh.ttc', $info_name); // 产生文本 横向长度 #这里注意生成文本框的内容和显示的内容要统一，不然不能做到文字居中显示，我在调试的时候因为这里的失误耽误的不少时间 $nameTextBox[2]; // 文字坐标居中 $dst_name_x = ($dst_w-$nameTextBox[2])/2; $dst_name_y = 325; // 透明度 100 为不透明 $pct = 100; $Rand_color = imagecolorallocate($dst_im, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255)); $white = imagecolorallocate($dst_im,255,255,255); imagettftext($dst_im, 18, 0, $dst_name_x, $dst_name_y, $white, 'msyh.ttc', $info_name);// 这里要注意一点，如果引入的字体不支持中文会导致中文乱码的情况出现。&lt;!-- 写入文字数据 End --&gt;header("content-type:image/png"); $path_wx = createfolder('zsssc'); $picname = $openid.'_WXPIC.png'; $zo_pic_path = $path_wx.$picname;// imagepng($dst_im); # 输出到页面显示imagepng($dst_im,$zo_pic_path); # 输出到指定目录// 背景资源imagedestroy($dst_im);// 头像资源imagedestroy($src_im);// 头像缩略资源imagedestroy($min);// QR资源imagedestroy($qr_mi);// QR缩略资源imagedestroy($qr_copy);echo str_replace("/xxxx/xxxxn/sexxxxloy/","http://",$zo_xxx_path); exit; # 返回图片路径?&gt; 切圆部分代码是百度到的，来源应该是这个博客 http://www.zhaokeli.com 12总结 难点部分主要是对图片的切圆处理，其余部分就看对GD库的熟悉程度了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>PHP_GD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Kingeditor]]></title>
    <url>%2F2018%2F%E5%85%B3%E4%BA%8E-Kingeditor%2F</url>
    <content type="text"><![CDATA[Kingeditor 是一款比较老的富文本编辑器，好像已经停止更新了。因为之前项目中有用到这款编辑器的传图功能，并且也存在一些不完善的地方，再回头来进行一些调整。 关于关闭网络传图功能：在百度上找到一些答案但都没有达到想要的效果，最后查看 Kingeditor官网] demo找到了。http://kindeditor.net/demo.php 还有一些关于传图路径的设置： 我这里使用的是php开发的，其相关设置是在 upload_json.php 文件中。这里要注意区分 图片存储的物理目录 和 图片访问时的虚拟目录 之间的设置。 总结： 有官方文档的内容，遇到问题要先从官方的文档和demo中查找问题的解决方案。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHPMailer]]></title>
    <url>%2F2018%2FPHPMailer%2F</url>
    <content type="text"><![CDATA[之前做了一个 发送邮件的demo，在本地测试完成之后就没动过，昨天上传到服务器（服务器环境是LAMP）之后发现邮件发送时网页非常卡顿，最后报错503 邮件发送失败百度找到的方法也是千奇百怪，不过总结下来最多的情况就是端口占用和php.ini 的配置。我这里最后解决是 配置了php.ini 文件 123配置 openssl,在php.ini文件中，找到extension=php_openssl.dll，把前面的“；”去掉，重启apache。然后查看allow_url_fopen allow_url_fopen = On再查看是不是禁用函数了 disable_functions = pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority 然后 把发邮件的SMTP端口由25更换为ssl加密对应的端口 之后解决的问题。 123456789101112SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。SSL协议提供的服务主要有：1、认证用户和服务器，确保数据发送到正确的客户机和服务器；2、加密数据以防止数据中途被窃取；3、维护数据的完整性，确保数据在传输过程中不被改变。建议您在设置邮箱时使用SSL协议，这样会保障您邮箱更安全的使用。使用方法：当您选择了使用SSL协议时，请您同时修改各收/发件服务器端口号。 邮件服务器名称 服务器地址 端口号 POP3服务器 pop.126.com 110 SMTP服务器 smtp.126.com 25 IMAP服务器 imap.126.com 143注：若您关闭了SSL，请将端口号修改回来，POP3的为110，IMAP的为143，SMTP的为25。 中间测试和很久，总结下来用该非加密的邮件在Linux或者最新版的PHPMailer中运行传递被限制，25端口被占用也会引起这样的情况，但是我再测试时已经把占用25端口的服务关闭了。在本地的测试环境是可以用25端口正常发送，但是在没有手动开启openssl时是不能用ssl发送邮件的。所以，后面再碰到类似的情况，服务限制（比如ssl扩展是否开启）和端口占用方便查起。 123456789101112网上的朋友还有说开启 SElinux 的，但是个人测试来看没有效果，可能是赵成问题的原因不一样。vim /etc/selinux/configdisabled检查服务器发信权限：#$ getsebool httpd_can_sendmailhttpd_can_sendmail --&gt; off#$ getsebool httpd_can_network_connecthttpd_can_network_connect --&gt; off如果出现上面的提示，则表明SElinux已经禁用了发信权限，需要按下面操作开启。#$ setsebool -P httpd_can_sendmail 1#$ setsebool -P httpd_can_network_connect 1请注意上面的操作需要在root权限下操作，如果不行请在命令前加上sudo。 12345中间参考的博文地址在这里，各位可以参考http://drupalchina.cn/forum/302.htmlhttp://blog.csdn.net/kunpeng1987/article/details/78494256http://blog.csdn.net/xinluke/article/details/51925293http://help.163.com/10/1111/15/6L7HMASV00753VB8.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于递归]]></title>
    <url>%2F2018%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[最近在学习 Python ，不可避免的再一次跪倒在递归的裙摆之下。好记性不如烂笔头，温故而知新。在此记录一般循环和递归的对比。先看循环体：123456789101112131415161718192021def a(n): f1 = 1 f2 = 1 if n &lt;= 2: return 2 if n &gt; 2: while(n &gt; 2): f3 = f1+f2 f1 = f2 f2 = f3 n-=1 return f3print a(10)递归：def c(n): if n&gt;2: fn = c(n-1)+c(n-2) return fn else: return 1print c(10)获取兔子总数，要获得数列可以用 append 方法依次往初始化数列中添加。总体看下来 递归更偏向于抽象的拆分，这并不意味着递归的效率最高，在Python中递归的默认层数为100层，如果递归层数过多，对系统也是一种负担，总之根据项目需求灵活应变才是正道。 如果对递归理解不是那么容易的话，就把整个过程看做两个方面：The Frist 递归到最后必须要出现终止，无限递归可不好玩，所以就有了 if else 来区分递归深入和递归终止。The Second 有了第一部分的递归终止，你要求得的结果就可以由 递归终止 开始一步一步向上求值获得。这样反过来理解 可能会好一些。下面写关于 汉诺塔 的递归代码 12345678def e(n,o,t,s): if n&gt;=2: e(n-1,o,s,t) e(1,o,t,s) e(n-1,t,o,s) else: print o+'===&gt;'+se(2,'o','t','s') 汉诺塔的移动也可以分为两个方面：The Frist 不论现在o柱子上有多少层，(当然，肯定是大于一的)都把他们抽象的看做两层，The Second 现在你要做的就是 把”第一层”由o柱移动到t柱 再把”第二层”由o柱移动到s柱 最后一步将”第一层”由t柱移动到s柱 这期间你要做的当然不是移动上面的盘子，你要做的是更换柱子的位子，就是更换调用函数时对参数重新赋值 这些都是抽象步骤，不考虑过程。将上面的兔子的两部分拿到这里，也是从”终止递归”开始一步步往上得到你最终的结果。你所有的结果一定是从”递归终止”最后一步开始的。 David LevithanWide Awake]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用sql函数]]></title>
    <url>%2F2017%2F%E5%B8%B8%E7%94%A8sql%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[做WEB开发，每天都要和数据库打交道，所以，常用的sql函数还是有必要记录下的，下面记录项目中经常使用到的sql函数 字符串拼接1CONCAT(char c1, char c2, ..., char cn) ，其中char代表字符串，定长与不定长均可以 1数值加和则可以直接使用 + 进行操作，其中不论数据类型，英文字母和汉字在计算过程中值默认是 0 指的注意的是，不论 + 号操作符还是 CONCAT 函数 ，参数中出现NULL值会导致结果为NULl值。 关于NUll值处理1234isnull(expr) # 如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。IFNULL(expr1,expr2) # 如 expr1 为 null 则输出 expr2 ，否则输出 expr1NULLIF(expr1,expr2) # 如 expr1 = expr1 则输出 NULL ，否则输出 expr1IS NOT NULL # 判断非 NULL ，而 非空判断 用 !='' 多字段排序1ORDER BY expr1 ASC,expr2 DESC,expr3,... 同一字段多种排序1ORDER BY FIELD(name,'Suzi','Ben') DESC # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 格式化时间戳1from_unixtime(addtime,'%Y-%m-%d %H:%i:%s') # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 日期操作12TO_DAYS(950501) # 给出一个日期 date，返回一个天数(从 0 年开始的天数)FROM_DAYS(TO_DAYS(950501)) # 给出一个天数 N，返回一个 DATE 值 字符串处理1UPPER('abc') # 小写变大写 结果集操作UNION 和 UNION ALLUNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。另外还有一点要注意 在对合并之后的结果集操作时，外层 select 的 表名称 要起别名，不然会报错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[FB_授权登录]]></title>
    <url>%2F2017%2FFB-%E6%8E%88%E6%9D%83%E7%99%BB%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是要使用脸书授权用户登录，当时的我内心是这个表情 :-O虽然过后层并不是一帆风顺，但好在问题解决了。这个是 FB 官方文档地址，大家可以进去看看。developers.facebook.com因为项目是WEB，所以这里仅说明WEb端的步骤。下面贴出 FB 开发者账号设置步骤。 代码部分的话 其实单说FB授权跟WX授权流程基本一致，都是通过OAuth2FB 对PHPer还是比较友好的，有相关的SDK获取这个SDK之后基本上只需要将自己的应用编号和秘钥填进去就可以了 推荐几个翻墙工具 赛风翻墙软件下载 https://github.com/XL2014/vpn/raw/master/psiphon3.exe tunnello 谷歌浏览器插件VPN 每天200M流量 http://www.chromedownloads.net/extensions/622.html 这个插件 可以直接在Google商店 直接搜索到，注册账号之后 就可以使用 在注册账号的时候需要 通过VPN 到外网注册 总结 使用FB账号时，尽量不要切换IP，IP切换频繁的话会被封号，我完成项目之前被封了4个帐号 emmm 这一点的话推荐还是找有固定IP的VPN。 回头再看也没有比较麻烦的地方，但是对于FB开发者账号的应用还是知之甚少。但就授权来说，主要还是跳转授权的地址要确定配置成为能访问到FB。这一点上我们运维很厉害了，哈哈。 代码部分后面存放在百度云盘再贴出来。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FaceBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建过程]]></title>
    <url>%2F2017%2FHexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这里记录是从 配置环境之后的记录 有需要环境配置的朋友自行百度。 首先第一步 要创建自己的GitHub账号 传送门 GitHub 第二步 使用自己的GitHub账号建库 库名格式必须为 GitHub账号.github.io 在创建库时要注意最后这一个选项 要打勾，否者后面将不能添加绑定域名 第三步 进入库的设置将自己的域名添加进去 第四步 将自己的域名解析到 GitHub 的IP 注意这里的Ip有可能会产生变化从而导致解析失效。 常用的 HEXO 命令 123456789hexo n "新文章名字" # 新建文章hexo g # 清除 public 文件有时清除不干净导致无法更新博客内容，这是可以手动删除 public 文件夹hexo s # 开启本地服务hexo d # 将本地文件上载更新到Git库中hexo 文件中 代码标签一行必须从行首开始否者不会生效导致原样输出 总结 整体搭建还算简单主要是一些配置文件不熟悉，这篇博文后续跟上 环境搭建 的步骤 现在还欠缺的有博文评论功能 也在后续跟上吧]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇总]]></title>
    <url>%2F2017%2F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake [title] [] [url] [link text]1code snippet 样例普通的代码块 1alert('Hello World!'); alert(‘Hello World!’);指定语言 php输出123$arr = array('23','kk'=&gt;3);implode(',',$arr);[rectangle setX: 10 y: 10 width: 20 height: 20]; 1[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20];附加说明 Array.map1array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg])附加说明和网址 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] .compactUnderscore.js .compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 查找文章编写的标签背景图片更换 Ingrid Michaeson百度检测添加 正确认识和使用 标签以及分类]]></content>
  </entry>
</search>
