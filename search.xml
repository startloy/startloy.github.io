<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHPMailer]]></title>
    <url>%2F2018%2FPHPMailer%2F</url>
    <content type="text"><![CDATA[之前做了一个 发送邮件的demo，在本地测试完成之后就没动过，昨天上传到服务器（服务器环境是LAMP）之后发现邮件发送时网页非常卡顿，最后报错503 邮件发送失败百度找到的方法也是千奇百怪，不过总结下来最多的情况就是端口占用和php.ini 的配置。我这里最后解决是 配置了php.ini 文件 123配置 openssl,在php.ini文件中，找到extension=php_openssl.dll，把前面的“；”去掉，重启apache。然后查看allow_url_fopen allow_url_fopen = On再查看是不是禁用函数了 disable_functions = pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority 然后 把发邮件的SMTP端口由25更换为ssl加密对应的端口 之后解决的问题。 123456789101112SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。SSL协议提供的服务主要有：1、认证用户和服务器，确保数据发送到正确的客户机和服务器；2、加密数据以防止数据中途被窃取；3、维护数据的完整性，确保数据在传输过程中不被改变。建议您在设置邮箱时使用SSL协议，这样会保障您邮箱更安全的使用。使用方法：当您选择了使用SSL协议时，请您同时修改各收/发件服务器端口号。 邮件服务器名称 服务器地址 端口号 POP3服务器 pop.126.com 110 SMTP服务器 smtp.126.com 25 IMAP服务器 imap.126.com 143注：若您关闭了SSL，请将端口号修改回来，POP3的为110，IMAP的为143，SMTP的为25。 中间测试和很久，总结下来用该非加密的邮件在Linux或者最新版的PHPMailer中运行传递被限制，25端口被占用也会引起这样的情况，但是我再测试时已经把占用25端口的服务关闭了。在本地的测试环境是可以用25端口正常发送，但是在没有手动开启openssl时是不能用ssl发送邮件的。所以，后面再碰到类似的情况，服务限制（比如ssl扩展是否开启）和端口占用方便查起。 12345中间参考的博文地址在这里，各位可以参考http://drupalchina.cn/forum/302.htmlhttp://blog.csdn.net/kunpeng1987/article/details/78494256http://blog.csdn.net/xinluke/article/details/51925293http://help.163.com/10/1111/15/6L7HMASV00753VB8.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于递归]]></title>
    <url>%2F2018%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[最近在学习 Python ，不可避免的再一次跪倒在递归的裙摆之下。好记性不如烂笔头，温故而知新。在此记录一般循环和递归的对比。先看循环体：123456789101112131415161718192021def a(n): f1 = 1 f2 = 1 if n &lt;= 2: return 2 if n &gt; 2: while(n &gt; 2): f3 = f1+f2 f1 = f2 f2 = f3 n-=1 return f3print a(10)递归：def c(n): if n&gt;2: fn = c(n-1)+c(n-2) return fn else: return 1print c(10)获取兔子总数，要获得数列可以用 append 方法依次往初始化数列中添加。总体看下来 递归更偏向于抽象的拆分，这并不意味着递归的效率最高，在Python中递归的默认层数为100层，如果递归层数过多，对系统也是一种负担，总之根据项目需求灵活应变才是正道。 如果对递归理解不是那么容易的话，就把整个过程看做两个方面：The Frist 递归到最后必须要出现终止，无限递归可不好玩，所以就有了 if else 来区分递归深入和递归终止。The Second 有了第一部分的递归终止，你要求得的结果就可以由 递归终止 开始一步一步向上求值获得。这样反过来理解 可能会好一些。下面写关于 汉诺塔 的递归代码 12345678def e(n,o,t,s): if n&gt;=2: e(n-1,o,s,t) e(1,o,t,s) e(n-1,t,o,s) else: print o+'===&gt;'+se(2,'o','t','s') 汉诺塔的移动也可以分为两个方面：The Frist 不论现在o柱子上有多少层，(当然，肯定是大于一的)都把他们抽象的看做两层，The Second 现在你要做的就是 把”第一层”由o柱移动到t柱 再把”第二层”由o柱移动到s柱 最后一步将”第一层”由t柱移动到s柱 这期间你要做的当然不是移动上面的盘子，你要做的是更换柱子的位子，就是更换调用函数时对参数重新赋值 这些都是抽象步骤，不考虑过程。将上面的兔子的两部分拿到这里，也是从”终止递归”开始一步步往上得到你最终的结果。你所有的结果一定是从”递归终止”最后一步开始的。 David LevithanWide Awake]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用sql函数]]></title>
    <url>%2F2017%2F%E5%B8%B8%E7%94%A8sql%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[做WEB开发，每天都要和数据库打交道，所以，常用的sql函数还是有必要记录下的，下面记录项目中经常使用到的sql函数 字符串拼接1CONCAT(char c1, char c2, ..., char cn) ，其中char代表字符串，定长与不定长均可以 1数值加和则可以直接使用 + 进行操作，其中不论数据类型，英文字母和汉字在计算过程中值默认是 0 指的注意的是，不论 + 号操作符还是 CONCAT 函数 ，参数中出现NULL值会导致结果为NULl值。 关于NUll值处理1234isnull(expr) # 如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。IFNULL(expr1,expr2) # 如 expr1 为 null 则输出 expr2 ，否则输出 expr1NULLIF(expr1,expr2) # 如 expr1 = expr1 则输出 NULL ，否则输出 expr1IS NOT NULL # 判断非 NULL ，而 非空判断 用 !='' 多字段排序1ORDER BY expr1 ASC,expr2 DESC,expr3,... 同一字段多种排序1ORDER BY FIELD(name,'Suzi','Ben') DESC # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 格式化时间戳1from_unixtime(addtime,'%Y-%m-%d %H:%i:%s') # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 日期操作12TO_DAYS(950501) # 给出一个日期 date，返回一个天数(从 0 年开始的天数)FROM_DAYS(TO_DAYS(950501)) # 给出一个天数 N，返回一个 DATE 值 字符串处理1UPPER('abc') # 小写变大写 结果集操作UNION 和 UNION ALLUNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。另外还有一点要注意 在对合并之后的结果集操作时，外层 select 的 表名称 要起别名，不然会报错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP_GD 图片合成]]></title>
    <url>%2F2017%2FPHP-GD-%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是 将切圆的微信头像、个人属性二维码、文字信息 合成到一张图片上传到前端进行显示。毕竟也是花了点时间做出来的东西，就在这里记录下吧 废话不说直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263&lt;?php$url_pic = "http://xxxxxx.bxxxn.xx/zxxx/getPic.php"; # 这里是通过自己的接口获取事先存在数据库中的微信头像地址$info_header = json_decode(https_request($url_pic,$data_info));$url_header = $info_header-&gt;msg;function yuan_img($imgpath = 'Logo.jpg') &#123; $src_img = null; $a = getimagesize($imgpath); switch ($a[2]) &#123; case 1: $src_img = imagecreatefromgif($imgpath); break; case 2: $src_img = imagecreatefromjpeg($imgpath); break; case 3: $src_img = imagecreatefrompng($imgpath); break; default: echo '图片格式不正确'; break; &#125; $wh = getimagesize($imgpath); $w = $wh[0]; $h = $wh[1]; $w = min($w, $h); $h = $w; $img = imagecreatetruecolor($w, $h); //这一句一定要有 imagesavealpha($img, true); //拾取一个完全透明的颜色,最后一个参数127为全透明 $bg = imagecolorallocatealpha($img, 255, 255, 255, 127); imagefill($img, 0, 0, $bg); $r = $w / 2; //圆半径 $y_x = $r; //圆心X坐标 $y_y = $r; //圆心Y坐标 for ($x = 0; $x &lt; $w; $x++) &#123; for ($y = 0; $y &lt; $h; $y++) &#123; $rgbColor = imagecolorat($src_img, $x, $y); if (((($x - $r) * ($x - $r) + ($y - $r) * ($y - $r)) &lt; ($r * $r))) &#123; imagesetpixel($img, $x, $y, $rgbColor); &#125; &#125; &#125; return $img;&#125;// 创建目录function createfolder($destFd) &#123; $year = date('Y'); $month = date('m'); $day = date('d'); $dirroot = dirname(__FILE__); $folder = $dirroot . "/" . $destFd . $year . "/" . $month . "/" . $day . "/"; if (! is_dir($folder)) &#123; mkdir($folder, 0777, true); &#125; return $folder; &#125;// 下载微信头像 微信头像的格式为 jpeg 最好写判断function download_img($url = "", $filename = "")&#123; $ch = curl_init(); //初始化一个curl句柄 $hd = fopen($filename,'wb'); //只写打开或新建一个二进制文件；只允许写数据 curl_setopt($ch,CURLOPT_URL,$url); //需要获取的 URL 地址 curl_setopt($ch,CURLOPT_FILE,$hd); //设置成资源流的形式 curl_setopt($ch,CURLOPT_HEADER,0); //启用时会将头文件的信息作为数据流输出。 //curl_setopt($ch,CURLOPT_RETURNTRANSFER,false);//以数据流的方式返回数据,false时直接显示 curl_setopt($ch,CURLOPT_TIMEOUT,60); //设置超时时间 curl_exec($ch); //执行curl curl_close($ch); //关闭curl会话 fclose($hd); //关闭句柄 return true;&#125;// die('获取微信头像失败');$wx_pic_path = 'Logo.jpg'; # 获取威信头像失败时使用的默认图片if ($url_header != null ) &#123; $path_wx = createfolder('wx_pic'); $picname = $openid.'_WXPIC.png'; $down_wx = download_img($url_header,$path_wx.$picname); if ($down_wx) &#123; $wx_pic_path = $path_wx.$picname; &#125; else &#123; $wx_pic_path = 'Logo.jpg'; &#125;&#125;&lt;!--切圆 Begin 被获取之前变圆形--&gt;$imgg = yuan_img($wx_pic_path);imagepng($imgg,$wx_pic_path);imagedestroy($imgg);&lt;!--切圆 End--&gt;&lt;!--微信 Begin 图片水印--&gt;$logo = $wx_pic_path;$filename = '1.png';// 判断微信头像格式$a = getimagesize($logo);switch ($a[2]) &#123; case 1: $src_im = imagecreatefromgif($logo); break; case 2: $src_im = imagecreatefromjpeg($logo); break; case 3: $src_im = imagecreatefrompng($logo); break; default: echo '图片格式不正确'; break;&#125;// 创建缩略图// 创建画布// $src_im = imagecreatefromjpeg($logo);list($src_w,$src_h) = getimagesize($logo);$min = imagecreatetruecolor(100,100);&lt;!--NB Begin 这里将切圆后的图片背景由黑色变透明色 --&gt;//2.上色$color=imagecolorallocate($min,255,255,255);//3.设置透明imagecolortransparent($min,$color);imagefill($min,0,0,$color);&lt;!--NB End --&gt;imagecopyresampled($min, $src_im, 0, 0, 0, 0, 100, 100, $src_w, $src_h);// 将图片创建为画布资源$dst_im = imagecreatefrompng($filename);list($dst_w,$dst_h) = getimagesize($filename);$dst_x = ($dst_w-100)/2;$dst_y = 180;// 透明度 100 为不透明$pct = 100;list($src_x,$src_y) = getimagesize($logo);imagecopymerge($dst_im, $min, $dst_x, $dst_y, 0, 0, 100, 100, $pct);&lt;!-- 微信 EDN --&gt;&lt;!-- QRCode Begin --&gt;// 通过openid生成专属二维码if ($openid != null) &#123; $url_ip='http://lightup.XXXXX.top/XXXXX.php?openid='.$openid; $ch = curl_init($url_ip); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120); // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); $result = curl_exec($ch); curl_close($ch); $res_qr = json_decode($result); $qr_url = $res_qr-&gt;msg;&#125;// 二维码图片资源list($qr_w,$qr_h) = getimagesize($qr_url);$qr_res = getimagesize($qr_url);switch ($qr_res[2]) &#123; case 1: $qr_mi = imagecreatefromgif($qr_url); break; case 2: $qr_mi = imagecreatefromjpeg($qr_url); break; case 3: $qr_mi = imagecreatefrompng($qr_url); break; default: echo '图片格式不正确';exit; break;&#125;// 缩略 二维码$qr_copy = imagecreatetruecolor(80, 80);imagecopyresampled($qr_copy, $qr_mi, 0, 0, 0, 0, 80, 80, $qr_w, $qr_h);$dst_qr_x = $dst_w-375;$dst_qr_y = 1035;// 透明度 100 为不透明$pct = 100;// 进行 copyimagecopymerge($dst_im, $qr_copy, $dst_qr_x, $dst_qr_y, 0, 0, 80, 80, $pct);&lt;!-- QRCode End --&gt;&lt;!-- 写入文字数据 Begin --&gt;$url_info='http://lightup.XXXX.top/zo_XXX/gXXXXX.php';$data_info = array( 'openid'=&gt;$openid, );function https_request($url, $data = null) &#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE); if (!empty($data))&#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($curl); curl_close($curl); return $output; &#125;// 获取个人信息$info_res = json_decode(https_request($url_info,$data_info));$info_name = $info_res-&gt;msg-&gt;name;$info_score = $info_res-&gt;msg-&gt;score;$info_class = $info_res-&gt;msg-&gt;class;// 姓名水印$nameTextBox = imagettfbbox(18, 0, 'msyh.ttc', $info_name); // 产生文本 横向长度 #这里注意生成文本框的内容和显示的内容要统一，不然不能做到文字居中显示，我在调试的时候因为这里的失误耽误的不少时间 $nameTextBox[2]; // 文字坐标居中 $dst_name_x = ($dst_w-$nameTextBox[2])/2; $dst_name_y = 325; // 透明度 100 为不透明 $pct = 100; $Rand_color = imagecolorallocate($dst_im, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255)); $white = imagecolorallocate($dst_im,255,255,255); imagettftext($dst_im, 18, 0, $dst_name_x, $dst_name_y, $white, 'msyh.ttc', $info_name);// 这里要注意一点，如果引入的字体不支持中文会导致中文乱码的情况出现。&lt;!-- 写入文字数据 End --&gt;header("content-type:image/png"); $path_wx = createfolder('zsssc'); $picname = $openid.'_WXPIC.png'; $zo_pic_path = $path_wx.$picname;// imagepng($dst_im); # 输出到页面显示imagepng($dst_im,$zo_pic_path); # 输出到指定目录// 背景资源imagedestroy($dst_im);// 头像资源imagedestroy($src_im);// 头像缩略资源imagedestroy($min);// QR资源imagedestroy($qr_mi);// QR缩略资源imagedestroy($qr_copy);echo str_replace("/xxxx/xxxxn/sexxxxloy/","http://",$zo_xxx_path); exit; # 返回图片路径?&gt; 切圆部分代码是百度到的，来源应该是这个博客 http://www.zhaokeli.com 12总结 难点部分主要是对图片的切圆处理，其余部分就看对GD库的熟悉程度了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>PHP_GD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FB_授权登录]]></title>
    <url>%2F2017%2FFB-%E6%8E%88%E6%9D%83%E7%99%BB%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是要使用脸书授权用户登录，当时的我内心是这个表情 :-O虽然过后层并不是一帆风顺，但好在问题解决了。这个是 FB 官方文档地址，大家可以进去看看。developers.facebook.com因为项目是WEB，所以这里仅说明WEb端的步骤。下面贴出 FB 开发者账号设置步骤。 代码部分的话 其实单说FB授权跟WX授权流程基本一致，都是通过OAuth2FB 对PHPer还是比较友好的，有相关的SDK获取这个SDK之后基本上只需要将自己的应用编号和秘钥填进去就可以了 推荐几个翻墙工具 赛风翻墙软件下载 https://github.com/XL2014/vpn/raw/master/psiphon3.exe tunnello 谷歌浏览器插件VPN 每天200M流量 http://www.chromedownloads.net/extensions/622.html 这个插件 可以直接在Google商店 直接搜索到，注册账号之后 就可以使用 在注册账号的时候需要 通过VPN 到外网注册 总结 使用FB账号时，尽量不要切换IP，IP切换频繁的话会被封号，我完成项目之前被封了4个帐号 emmm 这一点的话推荐还是找有固定IP的VPN。 回头再看也没有比较麻烦的地方，但是对于FB开发者账号的应用还是知之甚少。但就授权来说，主要还是跳转授权的地址要确定配置成为能访问到FB。这一点上我们运维很厉害了，哈哈。 代码部分后面存放在百度云盘再贴出来。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FaceBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建过程]]></title>
    <url>%2F2017%2FHexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这里记录是从 配置环境之后的记录 有需要环境配置的朋友自行百度。 首先第一步 要创建自己的GitHub账号 传送门 GitHub 第二步 使用自己的GitHub账号建库 库名格式必须为 GitHub账号.github.io 在创建库时要注意最后这一个选项 要打勾，否者后面将不能添加绑定域名 第三步 进入库的设置将自己的域名添加进去 第四步 将自己的域名解析到 GitHub 的IP 注意这里的Ip有可能会产生变化从而导致解析失效。 常用的 HEXO 命令 123456789hexo n "新文章名字" # 新建文章hexo g # 清除 public 文件有时清除不干净导致无法更新博客内容，这是可以手动删除 public 文件夹hexo s # 开启本地服务hexo d # 将本地文件上载更新到Git库中hexo 文件中 代码标签一行必须从行首开始否者不会生效导致原样输出 总结 整体搭建还算简单主要是一些配置文件不熟悉，这篇博文后续跟上 环境搭建 的步骤 现在还欠缺的有博文评论功能 也在后续跟上吧]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇总]]></title>
    <url>%2F2017%2F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake [title] [] [url] [link text]1code snippet 样例普通的代码块 1alert('Hello World!'); alert(‘Hello World!’);指定语言 php输出123$arr = array('23','kk'=&gt;3);implode(',',$arr);[rectangle setX: 10 y: 10 width: 20 height: 20]; 1[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20];附加说明 Array.map1array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg])附加说明和网址 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] .compactUnderscore.js .compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 查找文章编写的标签背景图片更换 Ingrid Michaeson百度检测添加 正确认识和使用 标签以及分类]]></content>
  </entry>
</search>
