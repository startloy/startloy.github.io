<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 定时任务笔记]]></title>
    <url>%2F2018%2FLinux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Imooc 视频笔记 检查 cron 服务 – 检查 Crontab 工具是否安装：crontab -l – 检查 crond 服务是否启动 service crond status 安装 cron – yum install vixie-cron – yum install crontabs 每分钟打印当前时间到一个日志文件中 – * COMMAND 0 ~ 59 分钟 0 ~ 23 小时 1 ~ 31 日期 1 ~ 12 月份 0 ~ 7 星期（0 或者 7 都表示星期天） 执行级别之间用空格间隔 – 表示任何时候都匹配– 可以用 “A,B,C” 表示A或者B或者C时执行命令– 可以用 “A-B” 表示A到B之间时执行命令– 可以用 “/A” 表示每A分钟(小时等) 执行一次命令 – tail -f /tmp/log.txt 持续输出 /tmp/log.txt 文件中的数据– tail -3 /tmp/log.txt 输出 /tmp/log.txt 文件中最后三条数据– tail /tmp/log.txt 输出 /tmp/log.txt 文件中所有数据 一个执行级别有多个数值的 用逗号间隔 30 21 service httpd restart // 每天 21:30 重启 apache服务// 离散型分布45 4 1,10,22 service httpd restart // 每月1、10、22 日 的4:45 重启 apache// 连续分布45 4 1-10 * service httpd restart // 每月 1 到 10 号 重启 Apache – /1 * date &gt;&gt; /tmp/log.txt // 每隔一分钟执行一次计划任务 斜线之前是执行范围，之后是频次 1-59/2 service httpd restart // 从第一分钟到59分钟内 每两分钟执行一次计划任务 （相当于只在奇数分钟时执行任务） 0 23-7/1 service httpd restart // 每天晚上的11点到第二天7点 重启 apache 若分钟数 写 则表示 在每天晚上的11点到第二天7点 的每一分钟都会重启 apache 0,30 18-23 service httpd restart // 每天18点至23点之间每隔30分钟重启apache0-59/30 18-23 service httpd restart // 每天18点至23点之间每隔30分钟重启apache crontab -help 查看 cron 命令帮助 crond 计划任务执行的日子记录在 /var/log/cron 文件中tail -f /var/log/cron // 查看任务执行日志 cron 的系统配置文件 /etc/crontab 可以通过编辑配置文件来实现系统级定时任务 cron.d 下的配置文件会自动载入为 root 用户的计划任务crontab 文件名 // 将文件中的内容导入计划任务 这里执行要特别小心，因为操作文件中的数据将会完全覆盖 crontab -e 编辑的计划任务，所以为了保证编辑的计划任务不丢失，可以选择将计划任务写入配置文件，再将文件通过 crontab 导入计划任务 在编辑系统中的 crond 配置文件时（cron.d目录下的），要注意写明计划所属用户 /2 username echo “编辑 crond 系统配置文件” /2 echo “编辑 crond 系统配置文件” // 编辑指定用户的定时任务不用指定用户 crontab 工具无法编辑 系统级别的计划任务（/etc/crontab &amp;&amp; /etc/cron.d/） root 用户可以通过编辑系统配置文件给指定用户 配置定时任务，但是 ctontab -e -u name命令编辑指定用户的计划任务时 是不能查看编辑 root指定或系统级的定时任务，但是在 定时任务执行日志中可以看到。 crontab -l // 输出当前用户的定时任务 cat /var/spool/cron/root // crontab -l 命令实际执行的文件 /var/log/ // 该目录下存放系统的日志文件 包括有 cron 定时任务的日志 ll cron* 查看 /var/spool/mail/ // 系统会将任务执行信息已邮件的形式发送给 root 用户。 ll -a // 查看当前用户家目录中的隐藏文件 在 root 家目录中有 .bash_profile 文件，是系统环境变量的配置文件。 在修改完成 .bash_profile 配置文件之后 执行 source .bash_profile 命令 重新载入配置文件 执行 echo $PATH // 输出 文件中设置号的环境变量 易错 在计划任务的脚本中会经常用到 在 .bash_profile 预设好的系统环境变量,但是这些变量 可以在命令中被识别出来，不一定在执行脚本中也能够被识别。 第三域 和 第五域 是 互为 ”或“ 关系； test `date +%w` -eq 0 || 1 || 2 || ... echo $? // 输出 0 标表示上述判断 成功 ， 输出 1 表示上述判断失败。 在命令行中使用 test 做判断时 要注意避免使用 = 号做判断，因为 test 会将 1=0 整体作为一个字符串处理 (test abd) 必须使用 = 号时，在 = 前后加空格 1 = 0 test 1 = 0 &amp;&amp; echo hello // 在 test 判断成立时 输出 hello &amp;&amp; 对应的是 || 四月的第一个星期日早上1时59分运行a.sh 59 1 1-7 4 0 /root/a.sh // 因为 第三域 和 第五域 互为 或 关系 任务会执行 10次 59 1 1-7 4 * test `date +\%w` -eq 0 &amp;&amp; /root/a.sh // 在定时任务中加上对于星期的判断 避免上述问题，这里要注意 在命令行中看可以直接输出 date +%w 但是在 脚本中要对 % 号进行转义 分钟设置误用 要注意 * 号 表示任意时刻都可执行 两小时运行一次 * */2 * * * /root/a.sh // 错误 0 */2 * * * /root/a.sh // 正确 crantab 最小执行单位是分钟，但是可以借助 sleep 命令 将最小执行单数扩展到秒 */1 * * * * date &gt;&gt; /tmp/date.log */1 * * * * sleep 30s; date &gt;&gt; /tmp/date.log // sleep 0.5s 上述借用 sleep 可以实现 定时任务在每分钟执行两次]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用汇总]]></title>
    <url>%2F2018%2F%E5%B8%B8%E7%94%A8%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[常用header头设置123456789header("Access-Control-Allow-Origin: *");header("Access-Control-Allow-Methods:OPTIONS,POST,GET");header("Access-Control-Allow-Headers:*");header("Access-Control-Allow-Credentials:true");session_start();header("content-type:text/html;charset=utf-8");date_default_timezone_set('PRC'); sql 常用函数12345678910 FROM_UNIXTIME(a.addtime, '%Y-%m-%d');TP 动态查询 $c_cid = M('Article')-&gt;getFieldById($aid[0],'cid');TP 获取sql语句 -&gt;fetchSql() 不执行SQL而只是返回SQL 布尔值 连贯操作 M()-&gt;getLastSql() M()-&gt;_sql() 获取最后一条执行的SQL语句 常用Linux命令1234567891011121314151617181920 mysql --version php -vhttpd -vcat /etc/redhat-release 查看当前linux 版本/usr/local/php/bin/php -i |less 查看配置文件在哪里，编译参数/usr/local/php/bin/php -m |less 查看php加载的模块which 文件名 查找文件所在目录df -hl 磁盘使用空间 dump 快速导出mysql数据mysqldump -h shujukudizhi -uyonghu -pmima globalsummit &gt; globalsummit.sqldu 命令查看文件大小使用ZIP属性压缩目录时 记得 -rzip -r mcc01.zip mcc01cp -rf /home/1.txt /opt/ (如果复制的是目录的话，必须需要加上 -rf 参数) 配置文件常用项123456789101112php.ini file_uploads = On # 支持HTTP上传 upload_tmp_dir = # 临时文件保存目录 upload_max_filesize = 2M # 允许上传文件的最大值 max_file_uploads = 20 # 允许一次上传的最大文件数 post_max_size = 8 # POST方式发送数据的最大值Win10 hosts 位置c:\Windows\System32\Drivers\etc PHP 常用常量12345678910111213141516171819202122232425262728293031323334353637383940声明常量 如何需要设置常量，可以使用define(constantName, constantValue, isCase)函数，它使用三个参数：第一个参数定义常量的名称第二个参数定义常量的值第三个参数是可选的，规定常量名是否对大小写敏感。默认是false。?系统常量 __dir__ 或者 dirname()__FILE__ 当前PHP文件的相对路径__LINE__ 当前PHP文件中所在的行号__FUNCTION__ 当前函数名，只对函数内调用起作用__CLASS__ 当前类名，只对类起作用PHP_VERSION 当前使用的PHP版本号PHP_OS 当前PHP环境的运行操作系统TRUE 与true一样FALSE 与false一样M_PI 圆周率常量值M_E 科学常数eM_LOG2E 代表log2 e，以2为底e的对数M_LOG10E 代表lg e，以10为底e的对数M_LN2 2的自然对数M_LN10 10的自然对数E_ERROR 最近的错误之处E_WARNING 最近的警告之处E_PARSE 剖析语法有潜在问题之处__METHOD__ 表示类方法名，比如B::test服务器全局变量 $_SERVER 返回服务器相关信息，返回一个数组$_GET 所有GET请求过来的参数$_POST 所有POST过来的参数$_COOKIE 所有HTTP提交过来的cookie$_FILES 所有HTTP提交过来的文件$_ENV 当前的执行环境信息$_REQUEST 相当于$_POST、$_GET、$_COOKIE提交过来的数据，因此这个变量不值得信任$_SESSION session会话变量 关于正则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293strip_tags()该函数尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果。它使用与函数 fgetss() 一样的机制去除标记。去除 html 标签$Artlist[0][content] = htmlspecialchars_decode($Artlist[0][content]);$Artlist[0][content] = preg_replace( "@&lt;script(.*?)&lt;/script&gt;@is", "", $Artlist[0][content] ); $Artlist[0][content] = preg_replace( "@&lt;iframe(.*?)&lt;/iframe&gt;@is", "", $Artlist[0][content] ); $Artlist[0][content] = preg_replace( "@&lt;style(.*?)&lt;/style&gt;@is", "", $Artlist[0][content] ); $Artlist[0][content] = preg_replace( "@&lt;(.*?)&gt;@is", "", $Artlist[0][content] ); /*/&lt;(?!\/?br\/?.+?&gt;|\/?img.+?&gt;)[^&lt;&gt;]*&gt;/gi*/ // 去除html标签 并保留 br 和 img 但是 g 会引起报错$a = preg_replace( '/&lt;(?!\/?br\/?.+?&gt;|\/?img.+?&gt;)[^&lt;&gt;]*&gt;/i', "", $a ); 用户邮箱验证function is_email($email)&#123; if (preg_match("/[a-za-z0-9]+@[a-za-z0-9]+.[a-z]&#123;2,4&#125;/",$email,$mail)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 验证用户名是否以字母开头function is_user_name($user) &#123; if (preg_match("/^[a-za-z]&#123;1&#125;([a-za-z0-9]|[._])&#123;3,19&#125;$/",$user,$username)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 验证密码只能为数字和字母的组合function is_psd($psd)&#123; if (preg_match("/^(w)&#123;4,20&#125;$/",$psd,$password)) &#123; return true; &#125; else &#123; return false; &#125;&#125;正则表达式中/i,/g,/ig,/gi,/m的区别和含义/i (忽略大小写)/g (全文查找出现的所有匹配字符)/m (多行查找)/gi(全文查找、忽略大小写)/ig(全文查找、忽略大小写) // 域名正则式 const URLRULE ='/^http[s]?:\/\/(([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;|([0-9a-z_!~*\'()-]+\.)*([0-9a-z][0-9a-z-]&#123;0,61&#125;)?[0-9a-z]\.[a-z]&#123;2,6&#125;)(:[0-9]&#123;1,4&#125;)?((\/\?)|(\/[0-9a-zA-Z_!~\*\'\(\)\.;\?:@&amp;=\+\$,%#-\/]*)?)$/'; //固定号码 const TELEPARSE = '/^[048]\d&#123;2,3&#125;-?\d&#123;3,4&#125;-?\d&#123;3,4&#125;(-\d&#123;1,&#125;)?$/'; //手机号码 const MOBILEPARSE = '/^(\+?86-?)?(18|17|15|13)[0-9]&#123;9&#125;$/'; //电话号码 const PHOTOPARSE = '/(^(\+?86-?)?(18|17|15|14|13)[0-9]&#123;9&#125;$)|(^[048]\d&#123;2,3&#125;-?\d&#123;3,4&#125;-?\d&#123;3,4&#125;(-\d&#123;1,&#125;)?$)/'; //时间格式 const DATERULE = '/^\\d&#123;4&#125;[-](0?[1-9]|1[012])[-](0?[1-9]|[12][0-9]|3[01])(\s+(0?[0-9]|[12][0-3]):(0?[0-9]|[1-5][1-9]):(0?[0-9]|[1-5][1-9]))?$/'; //邮箱地址 const MAILPARSE = '/^([0-9A-Za-z\\-_\\.]+)@([0-9a-z]+\\.[a-z]&#123;2,3&#125;(\\.[a-z]&#123;2&#125;)?)$/i'; //浮点数 const FLOAT = '/^\\d+(\\.\\d+)?$/'; //最多只能有两位小数 const TWODECIMAL = '/^\\d+(\\.\\d&#123;0,2&#125;+)?$/'; //数字 const INTEGER = '/^[0-9]*$/'; //"2090009973,2089948681" const SPLIT_INTEGER = '/^(\d[,]?)*$/'; //无特殊字符 const CHINESE = '/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125; A-Za-z0-9\-_\*\!\@\#\%\&amp;\(\)\,\.]+$/u'; //只能是0或者1 const ZORE_OR_ONE = '/^[0|1]*$/'; //连续出现两个&#123; const CONTINUOUS_BRACE = "/(&#123;[^&#123;^&#125;]+&#125;\s*)&#123;2&#125;/"; //四个&#123;&#125; const THREE_BRACE = "/(.*&#123;.*&#125;.+)&#123;4,&#125;/";]]></content>
  </entry>
  <entry>
    <title><![CDATA[不常遇到]]></title>
    <url>%2F2018%2F%E4%B8%8D%E5%B8%B8%E9%81%87%E5%88%B0%2F</url>
    <content type="text"><![CDATA[其实这里东西也挺重要的，要经常看，持续更新。 Http 请求更新一发12345678HTTP 415 错误 – 不支持的媒体类型(Unsupported media type)415 报错不常遇见，在发起请求的header头中设置对应的数据格式即可。PHP curl: $header = ['Content-Type:application/json']; curl_setopt($ch, CURLOPT_HTTPHEADER, $header); 首先第一个，微信授权相关的。1234567891011121314151617181920开发授权、分享需要数据整理微信 Oauth 和 微信 Share1、提供已经认证过的微信公众号的 AppID 和 AppSecret2、在微信公众平台 设置 使用的服务器对应的 IP 地址到白名单里面3、在微信公众平台 设置 安全回调地址 用以获取 access_token4、在微信公众平台 设置微信 JSSDK 分享安全域名微信授权处理过程中，发现OAuth2跳转过程极慢。以下为分析问题思路： 1、先确定服务器连接到微信服务器的速度 2、在服务器里面尝试增加其他的dns试试 3、看看curl代码有没有指定过期时间 4、去微信后台看统计数据，它有api调用的记录 5、我们自己也调用微信接口，没存在这种情况 最后解决 找到机器中的 hosts 文件添加以下DNS解析记录 58.246.220.31 api.weixin.qq.com 223.167.86.71 open.weixin.qq.com 按道理阿里的DNS不应该这么慢的，不知道是什么原因（真的是要打架吗 = ，=!）。 Git 提交12345678910111213141516171819warning: LF will be replaced by CRLF in ...... The file will have its original line endings in your working directory. 上面报错的原因是： 原因是路径中存在 / 的符号转义问题，false就是不转换符号默认是true，相当于把路径的 / 符号进行转义，这样添加的时候就有问题解决方法： git config --global core.autocrlf falsefatal: HttpRequestException encountered 致命报错原因： Github 禁用了TLS v1.0 and v1.1，必须更新Windows的git凭证管理器。解决： https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.14.0 下载客户端 ： GCMW-1.14.0.exe 安装之后报错就会消失。 PHP 函数系列 123在合并多个数组并统一排序时会用到array_multisort() // 可以用来一次对多个数组进行排序，或者根据某一维或多维对多维数组进行排序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP CURL]]></title>
    <url>%2F2018%2FPHP-CURL%2F</url>
    <content type="text"><![CDATA[1234近期项目中需要和客户对接接口，接口中需要添加header头信息进行安全验证。然后就是无情翻车，最后查到原因是 PHP中 md5() 函数出来的加密序列默认是32位，md5($sign, true); 第二参数设置为 true 时会返回16位加密序列，但是16位加密序列包含不可显示字符，无法验证通过。（这里标识下，通过网站上面进行md5获得的16位的加密序列实际上是32序列截取中间16位之后的结果。） 这里贴上 php curl 封装的 post 和 get 请求，之前用https竟然死活请求不成功，更换为http才能行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function req_post($url = '', $param = '') &#123; if (empty($url) || empty($param)) &#123; return false; &#125; $appkey = '*******'; $appsecret = '****************************'; $timespan = time(); $guid = rand(1000,9999); $platform = 'sign'; $sign = $appkey.'|'.$timespan.'|'.$guid.'|'.$platform.'|'.$appsecret; $sign = strtoupper(md5($sign, false)); $postUrl = $url; $curlPost = $param; $ch = curl_init();//初始化curl curl_setopt($ch, CURLOPT_URL,$postUrl);//抓取指定网页 // curl_setopt($ch, CURLOPT_HEADER, 0);//设置header $header = ['platform:sign','timespan:'.$timespan,'guid:'.$guid,'sign:'.$sign]; //设置一个你的浏览器agent的header curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);// 要求结果为字符串且输出到屏幕上 curl_setopt($ch, CURLOPT_POST, 1);//post提交方式 curl_setopt($ch, CURLOPT_POSTFIELDS, $curlPost); $data = curl_exec($ch);//运行curl curl_close($ch); return $data; &#125;function get1($url) &#123; $appkey = '********'; $appsecret = '*******************'; $timespan = time(); $guid = rand(1000,9999); $platform = 'sign'; $sign = $appkey.'|'.$timespan.'|'.$guid.'|'.$platform.'|'.$appsecret; $sign = strtoupper(md5($sign, false)); $ch = curl_init(); curl_setopt($ch, CURLOPT_HTTPGET, true); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //TRUE 将curl_exec()获取的信息以字符串返回，而不是直接输出。 // $header = ['User-Agent: php test']; //设置一个你的浏览器agent的header $header = ['platform:sign','timespan:'.$timespan,'guid:'.$guid,'sign:'.$sign]; //设置一个你的浏览器agent的header curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_HEADER, 0); //返回response头部信息 curl_setopt($ch, CURLINFO_HEADER_OUT, true); //TRUE 时追踪句柄的请求字符串，从 PHP 5.1.3 开始可用。这个很关键，就是允许你查看请求header curl_setopt($ch, CURLOPT_URL, $url); $result = json_decode(curl_exec($ch), true); // echo curl_getinfo($ch, CURLINFO_HEADER_OUT); //官方文档描述是“发送请求的字符串”，其实就是请求的header。这个就是直接查看请求header，因为上面允许查看 curl_close($ch); return $result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python学习之Turtle]]></title>
    <url>%2F2018%2FPython%E5%AD%A6%E4%B9%A0%E4%B9%8BTurtle%2F</url>
    <content type="text"><![CDATA[第一次接触 Python 时是看小甲鱼的课程(哈哈~算是打个广告吧)“打飞机”游戏，之后因为零零碎碎的原因(其实就是懒= 。=)，学习总是断断续续的。Python 在图像处理这块确实比PHP要厉害。在博客中记录下 学习过程，防止过后又忘（不常用肯定会忘的啊）！ 123还有一点感悟就是，再看一些教程的时候总是很浮躁，固然能实现一些示例，但是往往会忽视一些比较基础的语法和概念。写代码的时候很少能感受出来，因为很多时候都是念着尽快实现功能，不会去想会不会有更好的实现方式，而更好的实现方式实际上是离不开对一门语言进行透彻的理解的。所以在时间不是特别紧的时候，一定要注意一些基础的东西。 12345678Python 33 个保留字 and elif import raise global as else in return nonlocal assert except is try ture break finally lambda while False class for not with None continue from or yield def if pass del Python 基础数据类型处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697浮点数类型的运算存在不确定尾数，不是Bug 0.1 + 0.2 不等于 0.3 原因 0.1 在机器语言中用 53位二进制表示小数部分， 约 10 的 负16次方 二进制 和 十进制 不是完全对等的关系 二进制表示小数可以无限接近10进制的小数，但不完全相同。 在浮点数间运算及比较用round()函数辅助浮点数可以采用科学计数法表示 使用字母 e 或 E 作为幂的符号，以10为基数，格式如下 &lt;a&gt;e&lt;b&gt; 表示 a*10的b次方复数类型 与数学中复数的概念一致 定义 j = 根号 (-1) ，以此为基础，构建数学体系 a+bj 被称为复数 ， 其中 a 是实部，b 是虚部。 z = 1.23e-4 + 5.6e + 89j z.real 获取实部 z.imag 获取虚部 x/y // 两数相除 获取浮点数结果 x//y // 整数除，x 与 y 之商 10//3 == 3 x%y // 余数，模运算 10%3 == 1 x**y // 幂运算，x 的 y 次幂，当 y 是小数时，进行开方运算，10**0.5 结果是 根号10数值运算函数 abs(x) // 获取 x 的绝对值 divmod(x, y) // 商余，同时输出 商 和 余数 pow(x, y [,z]) // (x**y)%z , [,z] 表示参数 z 可省略。 pow(3, pow(3, 99), 10000); // 结果为 4587 ，不求余的话 一半计算机是无法计算出这么大的数值的 round(x, d) // 对 x 进行四舍五入，d 是小数截取位数。 max(x1, x2 ... xn) // 获取最大值 min(x1, x2 ... xn) // 获取最小值 int(x) // 将 x 变成整数，舍弃小数部分 float(x) // 将 x 变成浮点数，增加小数部分 complex(x) // 将 x 变成复数，增加其虚数部分。 i%7 in [6,0] // 365 天休息日字符串处理函数 以 三个单引号 ''' 表示的字符 若没有赋值给任何变量 可以被作为注释使用 将一段字符逆序排列 '123456'[::-1] 3*'nn' 或 'nn'*3 // 将 nn 字符串 连续输出3次 字符串拼接 使用+ len(x) // 返回字符串长度 set(x) // 返回任意类型 x 对应的字符串形式 hex(x) 或 oct(x) 整数 x 的十六进制或八进制小写形式字符串 chr(x) // x 为Unicode编码 , 返回其对应的字符 ord(x) // x 为字符 , 返回其对应的Unicode编码 Python 的字符编码嗾使 Unicode编码 // chr(10004) -&gt; 输出 对勾 chr(9800) // 输出白羊座的图标 循环输出 12 星座图标 for i in range(12): a = 9800+i; print(chr(a),end = '\n\r');字符串处理方法 str.lower() 或 str.supper() // 返回字符串的副本,全部字符小写/大写 str.split(sep=None) // 返回有 sep 分割的 str 之后组成的数组 str.count(sup) // 计算 su 在str中出现的次数 str.replace(old, new) // 发返回字符串str副本,所有old子字符串被替换为new. str.center(width[,fillchar]) // 字符串 str 根据宽度居中,width为要输出的字符宽度, fillchar为居中后字符两侧需填充的内容. str.strip(chars) // 从 str 中去掉左侧和由此char中列出的所有字符 区分大小写 "= Python=".strip(" =np") str.join(iter) // 将字符 iter 中的每个元素后增加一个 str ",".join("1234") // 主要用于分割字符字符类型的格式化 &lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;) "&#123;1&#125;:计算机&#123;0&#125;的CPU占用率&#123;2&#125;%".format("2018-10-10", "C", "10"); &#123;&#125; 表示槽 , 槽中的参数序号 和 format 中参数一一对应 槽内部对格式化的配置方式 &#123;&lt;参数序号&gt; : &lt;格式控制标记&gt;&#125; 格式控制标记 : 引导符号 &lt;填充&gt; &lt;对齐&gt; &gt; 右对齐 &lt; 左对齐 ^ 居中对齐 &lt;宽度&gt; 槽设定的输出宽度 &lt; , &gt; 数字的千位分隔符 &lt;.精度&gt; 浮点数小数精度 或 字符串最大的输出长度 &lt;类型&gt; 整数类型 b,c,d,o,x,X ;浮点数类型 e,E,f,% "&#123;0:=^20&#125;".format("Python"); "&#123;0:,.2f&#125;".format(123456.444); "&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;".format(425); "&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;".format(425); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556程序的异常处理 try : &lt;语句块1&gt; except [&lt;异常类型&gt;]: // 在设置异常类型之后，try 语句块 只能响应设置后的异常类型 &lt;语句块2&gt;程序异常高级处理 try : &lt;语句块1&gt; except : &lt;语句块2&gt; else : &lt;语句块3&gt; finally : &lt;语句块4&gt; finally 所对应 语句块4 一定执行 else 所对应 语句块3 在不发生异常时执行 注意一个 break 关键字 只能跳出一层循环。循环 与 else 在循环语句 正常退出(不是通过 break 或 continue 退出)时 可以触发 else 中语句块 for c in "PYTHON" : if c == "T" : continue print(c, end="") else: print("正常退出") for c in "PYTHON": if c == "T": break print(c, end="") else: print("正常退出") 123456紧凑型的二分支结构 // 这里不是语句 而是表达式，是语句的一部分，只有判断没有赋值 &lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt; guess = eval(input()); print("猜&#123;&#125;了".format('对' if guess == 99 else '错')); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576turtle (海龟)库 是 turtle 绘图体系的 Python 实现 turtle 绘图体系诞生于1969年，主要用于程序设计入门 Python 语言的标准库之一 入门级的图形绘制函数库turtle 空间坐标体系 绝对坐标 海龟初始在 画布中心 坐标为 0,0 海龟坐标 有前进方向、后退方向、左侧方向、右侧方向。 fd(d) 表示海龟向 正前方运行 bk(d) 表示海龟向 正后方运行 circle() 表示以海龟当前坐标的左边某一点画圆turtle 角度坐标体系 绝对角度 x 轴正方向 表示 0/360 度 y 轴正方向 表示 90/-270 度 seth(angle) // 只改变海龟的行进方向但不行进 海龟角度 以海龟角度来控制 其行进角度 left(angle) right(angle)turtle 画笔控制函数 画笔操作后一直有效，一般成对出现 turtle.penup() 别名 turtle.pu() // 抬起画笔，海龟在飞行 turtle.pendown() 别名 turtle.pd() // 落下画笔，海龟在爬行 turtle.pensize(width) 别名 turtle.width(width) // 设置画笔宽度 turtle.pencolor(color) 为画笔设置颜色 color 为颜色字符串 或 r,g,b 值 color 的 填写形式有 字符串，多值调用，元组turtle 运动控制函数 turtle.forword(d) 别名 turtle.fd(d) // 向前行进，走直线 d表示行进距离，可为负数 turtle.circle(r, extent=None) 根据半径 r 绘制 extent 角度的弧形 r 默认圆心在海龟左侧 r 距离的位置，值为负数时，表示圆心在海归右侧 extent 绘制角度，默认是 360度 整圆程序最后加上 curcle.done() 函数之后 程序运行完成之后不会自动结束，要手动关闭窗口之后才会结束。 turtle.bgcolor(); // 设置画板背景颜色 t.color('black','black'); // 设置颜色 t.begin_fill(); 填充颜色 t.end_fill();turtle 方向控制函数 turtle.setheading(angle)别名 turtle.seth(angle) // 只改变方向，即海龟行进角度 在海龟视角的转向 turtle.left(angle) turtle.right(angle)turtle 的RGB色彩模式 turtle 默认采用 RGB 小数值来获取颜色 可切换为整数值 turtle.colormode(mode) mode = 1.0 : RGB 为小数值模式 mode = 255 : RGB 为整数值模式 turtle.setup(width, height, startx, starty); // 设置长提的大小和位置 后两个参数可选。 turtle.goto(x, y); // x方向 相对于海龟初始 0,0 坐标 移动 x 单位个像素; y方向 相对于海龟初始 0,0 坐标 移动 Y 单位个像素 turtle.hideturtle(); // 隐藏海龟箭头附加常用函数 turtle.bgcolor("black"); #设置画面背景色 turtle.bye(); #退出turtle，无任何提示信息 turtle.hideturtle(); #隐藏画笔 turtle.showturtle(); #显示画笔 12345678910111213141516171819202122232425262728293031Python 标准库之 Time 库time() 获取当前时间戳，即计算机内部时间值，浮点数ctime() 获取当前时间并以已读方式表示，返回字符串gmtime() 获取当前时间，表示计算机可处理的时间格式时间格式化函数 strftime(tpl, ts) tpl 是格式化模板字符串，用来定义输出效果。 ts 是计算机内部时间类型变量 time.strftime("%Y-%m-%d", time.gmtime()); strptime(str, tpl); str 是 字符串形式的时间值。 tpl 是 格式化模板字符串，用来定义输入效果。 timestr = '2018-01-26 12:10:1'; time.strptime(timestr, "%Y-%m-%d %H:%M:%S"); 这里注意 strptime 函数中两个参数的 精确程度要保持一致。程序计时 perf_counter() 返回一个CPU级别的精确时间计数值，单位为秒，由于这个计数值的起点不确定，连续调用才有意义。 sleep(s); // 使程序停止运行 s 秒， s 可以为浮点数 print(1,end = ''); // print 函数只有一个输出结果时，在输出完成之后默认换行。但是手动设置非首个参数的值之后，系统就会取消默认换行。 IDLE中屏蔽了 \r 功能 单行动态刷新无法实现。 文本进度条展示函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657这里是用 Turtle 实现的时间数码管。# 数码管绘制时间import turtle as tt.setup(800,300,200,200);t.pu();t.bk(300);t.pd();t.pencolor('pink');def drawline(draw): t.pensize(4) t.pd() if draw else t.pu(); t.fd(25); t.pu(); t.fd(5); t.right(90); t.fd(5); t.pd(); return;def drawdigit(x): drawline(1) if x in [2,3,4,5,6,8,9] else drawline(0); drawline(1) if x in [1,3,4,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [2,3,5,6,8,0] else drawline(0); drawline(1) if x in [2,6,8,0] else drawline(0); t.pu(); t.bk(5); t.left(90); t.fd(5); t.pd(); drawline(1) if x in [4,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [2,3,5,6,7,8,9,0] else drawline(0); drawline(1) if x in [1,2,3,4,7,8,9,0] else drawline(0); t.pu(); t.left(180); t.fd(10); t.pd(); return;def main(date = '20180612'): for index,i in enumerate(date): drawdigit(eval(i)); t.pu(); if index in [3,5]: t.fd(55); else : t.fd(10); t.pd(); return;main();t.hideturtle(); 其实还画了几个小时出来了一个小猪佩奇 但是因为没有封装函数，代码冗余是在是过分（好意思说？？？）就先不放源码了。嘿嘿~ 效果图来一张，源码整理之后再放]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP 会话控制总结]]></title>
    <url>%2F2018%2FPHP-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Imooc 网视频笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php HTTP 超文本传输协议 最大特点是无状态无连接 Cookie 保存在客户端中 内存 Cookie 由浏览器来维护，保存在内存中，浏览器关闭之后消失，存在时间短暂。 硬盘 Cookie 保存在硬盘中，有一个过期时间，除非用户手动清除或者到达过期时间,硬盘 Cookie 不会被删除，其存在时间是长期的。 bool setcookie ( string $name [, string $value = "" [, int $expire = 0 [, string $path = "" [, string $domain = "" [, bool $secure = false [, bool $httponly = false ]]]]]] ) $name 指定 Cookie 的名字 $value Cookie 的值 $expire 设置 Cookie 的过期时间，默认值为0，单位是秒 $path 设置 Cookie 的有效路径，默认是当前目录及子目录有效，也可以指定目录 $domain 设置 Cookie 的作用域，默认在本域下 $secure 设置是否 Cookie 只能通过 HTTPS 传输， 默认是 False $httponly 是否只能使用 HTTP 访问 Cookie ，默认是 false ，如果设置 True ，客户端JS就无法操作当前 Cookie 使用这个参数可以减少 XSS 攻击。 setcookie('test_loy','24',strtotime('+7 day'),'/'); setrawcookie() — 发送未经 URL 编码的 cookie 一旦设置 Cookie 后，下次打开页面时可以使用 $_COOKIE 读取。 Cookie 值同样也存在于 $_REQUEST。 通过设置 过期时间可以删除 Cookie 修改和删除 Cookie 的值，可以对Cookie重新设置，重新设置Cookie时要注意Cookie的有效路径是否一致。 通过 header 操作 Cookie header("Set-Cookie:name=value[;expires=date][;domain=domain][;path=path][;secure][;httponly]"); header("Set-Cookie:a=a1;expires=".gmdate('D, d M Y H:i:s \G\M\T',time()+3600)); // 添加过期时间 header("Set-Cookie:a=a1; httponly")); // 只能通过 http 方式读取 cookie header("Set-Cookie:a=a1; path=/test/a/")); // 设置 Cookie 的保存目录 以数组形式保存 Cookie setcookie('arr[uname]','loy',strtotime('+7 day')); setcookie('arr[age]','24',strtotime('+7 day')); setcookie('arr[sex]','0',strtotime('+7 day')); 通过 JS 操作 Cookie Cookie 缺陷 Cookie 中不要存储敏感数据，Cookie不是很安全，劫取Cookie之后可以用来Cookie欺骗 不要把Cookie当作客户端的存储器来使用，首先每个域名允许Cookie是有限制的，根据浏览器的不同限制也不同。 Cookie 中保存数据的最大字节数是4K Cookie设置之后每次请求都会附着再HTTP的投中一起发送，造成带宽浪费。 localStorage 代替 Cookie SESSION 会话是服务器和浏览器保有共同信息的这段时间。 1/准备建立会话时，PHP回先查看请求中是否包含 session_id ，如果没有服务器就会在自己的内存里创建一个新的变量，这个变量就是 session_id 2/服务器会把这个 session_id 发送到浏览器保存，一般浏览器会将这个 id 保存到 cookie 中 3/之后每次我的浏览器再去访问服务器的时候，都会携带 cookie 中存储的这个 session_id 这样服务器就认识这个浏览器了。 4/服务器端的 session_id 变量可以存储任意的会话数据，这些数据是经过序列化之后存放进去的，默认是写在文件中的。 5/每次浏览器访问服务器，都可以凭借自己的 session_id 到服务器的这个变量中认领自己的信息。 6/如果像销毁会话，可以删除会话中的数据，销毁会话文件。 PHP 配置文件中 session.save_path 指定了session 的默认保存路径 setcookie(session_name(), session_name(), time()+3600); 在使用 session_start() 开启会话控制时就会新生成一个 会话ID php 开启会话 session_start(); // 函数根据浏览器中是否含有 session_id 来判断是否创建会话 cookie 当检测到 浏览器中通过cookie传输的 session_id 不存在对应 session 文件或者浏览器中无 session_id 时，则会将 session 数据保存在新创建的 session 文件中 可以通过 $_SESSION 来设置和读取相关值， 销毁 session session_destroy(); session_id(); // 获取session_id session_id(123); // 指定 session_id 为123?&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP_GD 图片合成]]></title>
    <url>%2F2018%2FPHP-GD-%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是 将切圆的微信头像、个人属性二维码、文字信息 合成到一张图片上传到前端进行显示。毕竟也是花了点时间做出来的东西，就在这里记录下吧 废话不说直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263&lt;?php$url_pic = "http://xxxxxx.bxxxn.xx/zxxx/getPic.php"; # 这里是通过自己的接口获取事先存在数据库中的微信头像地址$info_header = json_decode(https_request($url_pic,$data_info));$url_header = $info_header-&gt;msg;function yuan_img($imgpath = 'Logo.jpg') &#123; $src_img = null; $a = getimagesize($imgpath); switch ($a[2]) &#123; case 1: $src_img = imagecreatefromgif($imgpath); break; case 2: $src_img = imagecreatefromjpeg($imgpath); break; case 3: $src_img = imagecreatefrompng($imgpath); break; default: echo '图片格式不正确'; break; &#125; $wh = getimagesize($imgpath); $w = $wh[0]; $h = $wh[1]; $w = min($w, $h); $h = $w; $img = imagecreatetruecolor($w, $h); //这一句一定要有 imagesavealpha($img, true); //拾取一个完全透明的颜色,最后一个参数127为全透明 $bg = imagecolorallocatealpha($img, 255, 255, 255, 127); imagefill($img, 0, 0, $bg); $r = $w / 2; //圆半径 $y_x = $r; //圆心X坐标 $y_y = $r; //圆心Y坐标 for ($x = 0; $x &lt; $w; $x++) &#123; for ($y = 0; $y &lt; $h; $y++) &#123; $rgbColor = imagecolorat($src_img, $x, $y); if (((($x - $r) * ($x - $r) + ($y - $r) * ($y - $r)) &lt; ($r * $r))) &#123; imagesetpixel($img, $x, $y, $rgbColor); &#125; &#125; &#125; return $img;&#125;// 创建目录function createfolder($destFd) &#123; $year = date('Y'); $month = date('m'); $day = date('d'); $dirroot = dirname(__FILE__); $folder = $dirroot . "/" . $destFd . $year . "/" . $month . "/" . $day . "/"; if (! is_dir($folder)) &#123; mkdir($folder, 0777, true); &#125; return $folder; &#125;// 下载微信头像 微信头像的格式为 jpeg 最好写判断function download_img($url = "", $filename = "")&#123; $ch = curl_init(); //初始化一个curl句柄 $hd = fopen($filename,'wb'); //只写打开或新建一个二进制文件；只允许写数据 curl_setopt($ch,CURLOPT_URL,$url); //需要获取的 URL 地址 curl_setopt($ch,CURLOPT_FILE,$hd); //设置成资源流的形式 curl_setopt($ch,CURLOPT_HEADER,0); //启用时会将头文件的信息作为数据流输出。 //curl_setopt($ch,CURLOPT_RETURNTRANSFER,false);//以数据流的方式返回数据,false时直接显示 curl_setopt($ch,CURLOPT_TIMEOUT,60); //设置超时时间 curl_exec($ch); //执行curl curl_close($ch); //关闭curl会话 fclose($hd); //关闭句柄 return true;&#125;// die('获取微信头像失败');$wx_pic_path = 'Logo.jpg'; # 获取威信头像失败时使用的默认图片if ($url_header != null ) &#123; $path_wx = createfolder('wx_pic'); $picname = $openid.'_WXPIC.png'; $down_wx = download_img($url_header,$path_wx.$picname); if ($down_wx) &#123; $wx_pic_path = $path_wx.$picname; &#125; else &#123; $wx_pic_path = 'Logo.jpg'; &#125;&#125;&lt;!--切圆 Begin 被获取之前变圆形--&gt;$imgg = yuan_img($wx_pic_path);imagepng($imgg,$wx_pic_path);imagedestroy($imgg);&lt;!--切圆 End--&gt;&lt;!--微信 Begin 图片水印--&gt;$logo = $wx_pic_path;$filename = '1.png';// 判断微信头像格式$a = getimagesize($logo);switch ($a[2]) &#123; case 1: $src_im = imagecreatefromgif($logo); break; case 2: $src_im = imagecreatefromjpeg($logo); break; case 3: $src_im = imagecreatefrompng($logo); break; default: echo '图片格式不正确'; break;&#125;// 创建缩略图// 创建画布// $src_im = imagecreatefromjpeg($logo);list($src_w,$src_h) = getimagesize($logo);$min = imagecreatetruecolor(100,100);&lt;!--NB Begin 这里将切圆后的图片背景由黑色变透明色 --&gt;//2.上色$color=imagecolorallocate($min,255,255,255);//3.设置透明imagecolortransparent($min,$color);imagefill($min,0,0,$color);&lt;!--NB End --&gt;imagecopyresampled($min, $src_im, 0, 0, 0, 0, 100, 100, $src_w, $src_h);// 将图片创建为画布资源$dst_im = imagecreatefrompng($filename);list($dst_w,$dst_h) = getimagesize($filename);$dst_x = ($dst_w-100)/2;$dst_y = 180;// 透明度 100 为不透明$pct = 100;list($src_x,$src_y) = getimagesize($logo);imagecopymerge($dst_im, $min, $dst_x, $dst_y, 0, 0, 100, 100, $pct);&lt;!-- 微信 EDN --&gt;&lt;!-- QRCode Begin --&gt;// 通过openid生成专属二维码if ($openid != null) &#123; $url_ip='http://lightup.XXXXX.top/XXXXX.php?openid='.$openid; $ch = curl_init($url_ip); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120); // curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); $result = curl_exec($ch); curl_close($ch); $res_qr = json_decode($result); $qr_url = $res_qr-&gt;msg;&#125;// 二维码图片资源list($qr_w,$qr_h) = getimagesize($qr_url);$qr_res = getimagesize($qr_url);switch ($qr_res[2]) &#123; case 1: $qr_mi = imagecreatefromgif($qr_url); break; case 2: $qr_mi = imagecreatefromjpeg($qr_url); break; case 3: $qr_mi = imagecreatefrompng($qr_url); break; default: echo '图片格式不正确';exit; break;&#125;// 缩略 二维码$qr_copy = imagecreatetruecolor(80, 80);imagecopyresampled($qr_copy, $qr_mi, 0, 0, 0, 0, 80, 80, $qr_w, $qr_h);$dst_qr_x = $dst_w-375;$dst_qr_y = 1035;// 透明度 100 为不透明$pct = 100;// 进行 copyimagecopymerge($dst_im, $qr_copy, $dst_qr_x, $dst_qr_y, 0, 0, 80, 80, $pct);&lt;!-- QRCode End --&gt;&lt;!-- 写入文字数据 Begin --&gt;$url_info='http://lightup.XXXX.top/zo_XXX/gXXXXX.php';$data_info = array( 'openid'=&gt;$openid, );function https_request($url, $data = null) &#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE); if (!empty($data))&#123; curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($curl); curl_close($curl); return $output; &#125;// 获取个人信息$info_res = json_decode(https_request($url_info,$data_info));$info_name = $info_res-&gt;msg-&gt;name;$info_score = $info_res-&gt;msg-&gt;score;$info_class = $info_res-&gt;msg-&gt;class;// 姓名水印$nameTextBox = imagettfbbox(18, 0, 'msyh.ttc', $info_name); // 产生文本 横向长度 #这里注意生成文本框的内容和显示的内容要统一，不然不能做到文字居中显示，我在调试的时候因为这里的失误耽误的不少时间 $nameTextBox[2]; // 文字坐标居中 $dst_name_x = ($dst_w-$nameTextBox[2])/2; $dst_name_y = 325; // 透明度 100 为不透明 $pct = 100; $Rand_color = imagecolorallocate($dst_im, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255)); $white = imagecolorallocate($dst_im,255,255,255); imagettftext($dst_im, 18, 0, $dst_name_x, $dst_name_y, $white, 'msyh.ttc', $info_name);// 这里要注意一点，如果引入的字体不支持中文会导致中文乱码的情况出现。&lt;!-- 写入文字数据 End --&gt;header("content-type:image/png"); $path_wx = createfolder('zsssc'); $picname = $openid.'_WXPIC.png'; $zo_pic_path = $path_wx.$picname;// imagepng($dst_im); # 输出到页面显示imagepng($dst_im,$zo_pic_path); # 输出到指定目录// 背景资源imagedestroy($dst_im);// 头像资源imagedestroy($src_im);// 头像缩略资源imagedestroy($min);// QR资源imagedestroy($qr_mi);// QR缩略资源imagedestroy($qr_copy);echo str_replace("/xxxx/xxxxn/sexxxxloy/","http://",$zo_xxx_path); exit; # 返回图片路径?&gt; 切圆部分代码是百度到的，来源应该是这个博客 http://www.zhaokeli.com 12总结 难点部分主要是对图片的切圆处理，其余部分就看对GD库的熟悉程度了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>PHP_GD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Kingeditor]]></title>
    <url>%2F2018%2F%E5%85%B3%E4%BA%8E-Kingeditor%2F</url>
    <content type="text"><![CDATA[Kingeditor 是一款比较老的富文本编辑器，好像已经停止更新了。因为之前项目中有用到这款编辑器的传图功能，并且也存在一些不完善的地方，再回头来进行一些调整。 关于关闭网络传图功能：在百度上找到一些答案但都没有达到想要的效果，最后查看 Kingeditor官网] demo找到了。http://kindeditor.net/demo.php 还有一些关于传图路径的设置： 我这里使用的是php开发的，其相关设置是在 upload_json.php 文件中。这里要注意区分 图片存储的物理目录 和 图片访问时的虚拟目录 之间的设置。 总结： 有官方文档的内容，遇到问题要先从官方的文档和demo中查找问题的解决方案。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHPMailer]]></title>
    <url>%2F2018%2FPHPMailer%2F</url>
    <content type="text"><![CDATA[之前做了一个 发送邮件的demo，在本地测试完成之后就没动过，昨天上传到服务器（服务器环境是LAMP）之后发现邮件发送时网页非常卡顿，最后报错503 邮件发送失败百度找到的方法也是千奇百怪，不过总结下来最多的情况就是端口占用和php.ini 的配置。我这里最后解决是 配置了php.ini 文件 123配置 openssl,在php.ini文件中，找到extension=php_openssl.dll，把前面的“；”去掉，重启apache。然后查看allow_url_fopen allow_url_fopen = On再查看是不是禁用函数了 disable_functions = pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority 然后 把发邮件的SMTP端口由25更换为ssl加密对应的端口 之后解决的问题。 123456789101112SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。SSL协议提供的服务主要有：1、认证用户和服务器，确保数据发送到正确的客户机和服务器；2、加密数据以防止数据中途被窃取；3、维护数据的完整性，确保数据在传输过程中不被改变。建议您在设置邮箱时使用SSL协议，这样会保障您邮箱更安全的使用。使用方法：当您选择了使用SSL协议时，请您同时修改各收/发件服务器端口号。 邮件服务器名称 服务器地址 端口号 POP3服务器 pop.126.com 110 SMTP服务器 smtp.126.com 25 IMAP服务器 imap.126.com 143注：若您关闭了SSL，请将端口号修改回来，POP3的为110，IMAP的为143，SMTP的为25。 中间测试和很久，总结下来用该非加密的邮件在Linux或者最新版的PHPMailer中运行传递被限制，25端口被占用也会引起这样的情况，但是我再测试时已经把占用25端口的服务关闭了。在本地的测试环境是可以用25端口正常发送，但是在没有手动开启openssl时是不能用ssl发送邮件的。所以，后面再碰到类似的情况，服务限制（比如ssl扩展是否开启）和端口占用方便查起。 123456789101112网上的朋友还有说开启 SElinux 的，但是个人测试来看没有效果，可能是赵成问题的原因不一样。vim /etc/selinux/configdisabled检查服务器发信权限：#$ getsebool httpd_can_sendmailhttpd_can_sendmail --&gt; off#$ getsebool httpd_can_network_connecthttpd_can_network_connect --&gt; off如果出现上面的提示，则表明SElinux已经禁用了发信权限，需要按下面操作开启。#$ setsebool -P httpd_can_sendmail 1#$ setsebool -P httpd_can_network_connect 1请注意上面的操作需要在root权限下操作，如果不行请在命令前加上sudo。 12345中间参考的博文地址在这里，各位可以参考http://drupalchina.cn/forum/302.htmlhttp://blog.csdn.net/kunpeng1987/article/details/78494256http://blog.csdn.net/xinluke/article/details/51925293http://help.163.com/10/1111/15/6L7HMASV00753VB8.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于递归]]></title>
    <url>%2F2018%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[最近在学习 Python ，不可避免的再一次跪倒在递归的裙摆之下。好记性不如烂笔头，温故而知新。在此记录一般循环和递归的对比。先看循环体：123456789101112131415161718192021def a(n): f1 = 1 f2 = 1 if n &lt;= 2: return 2 if n &gt; 2: while(n &gt; 2): f3 = f1+f2 f1 = f2 f2 = f3 n-=1 return f3print a(10)递归：def c(n): if n&gt;2: fn = c(n-1)+c(n-2) return fn else: return 1print c(10)获取兔子总数，要获得数列可以用 append 方法依次往初始化数列中添加。总体看下来 递归更偏向于抽象的拆分，这并不意味着递归的效率最高，在Python中递归的默认层数为100层，如果递归层数过多，对系统也是一种负担，总之根据项目需求灵活应变才是正道。 如果对递归理解不是那么容易的话，就把整个过程看做两个方面：The Frist 递归到最后必须要出现终止，无限递归可不好玩，所以就有了 if else 来区分递归深入和递归终止。The Second 有了第一部分的递归终止，你要求得的结果就可以由 递归终止 开始一步一步向上求值获得。这样反过来理解 可能会好一些。下面写关于 汉诺塔 的递归代码 12345678def e(n,o,t,s): if n&gt;=2: e(n-1,o,s,t) e(1,o,t,s) e(n-1,t,o,s) else: print o+'===&gt;'+se(2,'o','t','s') 汉诺塔的移动也可以分为两个方面：The Frist 不论现在o柱子上有多少层，(当然，肯定是大于一的)都把他们抽象的看做两层，The Second 现在你要做的就是 把”第一层”由o柱移动到t柱 再把”第二层”由o柱移动到s柱 最后一步将”第一层”由t柱移动到s柱 这期间你要做的当然不是移动上面的盘子，你要做的是更换柱子的位子，就是更换调用函数时对参数重新赋值 这些都是抽象步骤，不考虑过程。将上面的兔子的两部分拿到这里，也是从”终止递归”开始一步步往上得到你最终的结果。你所有的结果一定是从”递归终止”最后一步开始的。 David LevithanWide Awake]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用sql函数]]></title>
    <url>%2F2017%2F%E5%B8%B8%E7%94%A8sql%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[做WEB开发，每天都要和数据库打交道，所以，常用的sql函数还是有必要记录下的，下面记录项目中经常使用到的sql函数 字符串拼接1CONCAT(char c1, char c2, ..., char cn) ，其中char代表字符串，定长与不定长均可以 1数值加和则可以直接使用 + 进行操作，其中不论数据类型，英文字母和汉字在计算过程中值默认是 0 指的注意的是，不论 + 号操作符还是 CONCAT 函数 ，参数中出现NULL值会导致结果为NULl值。 关于NUll值处理1234isnull(expr) # 如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。IFNULL(expr1,expr2) # 如 expr1 为 null 则输出 expr2 ，否则输出 expr1NULLIF(expr1,expr2) # 如 expr1 = expr1 则输出 NULL ，否则输出 expr1IS NOT NULL # 判断非 NULL ，而 非空判断 用 !='' 多字段排序1ORDER BY expr1 ASC,expr2 DESC,expr3,... 同一字段多种排序1ORDER BY FIELD(name,'Suzi','Ben') DESC # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 格式化时间戳1from_unixtime(addtime,'%Y-%m-%d %H:%i:%s') # 该函数根据某一字段的值进行排序，如果没有填写字段的所有情况的值，将先按未填写在函数中的字段进行排序。而后再按函数内字段排序。 日期操作12TO_DAYS(950501) # 给出一个日期 date，返回一个天数(从 0 年开始的天数)FROM_DAYS(TO_DAYS(950501)) # 给出一个天数 N，返回一个 DATE 值 字符串处理1UPPER('abc') # 小写变大写 结果集操作UNION 和 UNION ALLUNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。另外还有一点要注意 在对合并之后的结果集操作时，外层 select 的 表名称 要起别名，不然会报错。]]></content>
  </entry>
  <entry>
    <title><![CDATA[FB_授权登录]]></title>
    <url>%2F2017%2FFB-%E6%8E%88%E6%9D%83%E7%99%BB%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前段时间有项目需求是要使用脸书授权用户登录，当时的我内心是这个表情 :-O虽然过后层并不是一帆风顺，但好在问题解决了。这个是 FB 官方文档地址，大家可以进去看看。developers.facebook.com因为项目是WEB，所以这里仅说明WEb端的步骤。下面贴出 FB 开发者账号设置步骤。 代码部分的话 其实单说FB授权跟WX授权流程基本一致，都是通过OAuth2FB 对PHPer还是比较友好的，有相关的SDK获取这个SDK之后基本上只需要将自己的应用编号和秘钥填进去就可以了 推荐几个翻墙工具 赛风翻墙软件下载 https://github.com/XL2014/vpn/raw/master/psiphon3.exe tunnello 谷歌浏览器插件VPN 每天200M流量 http://www.chromedownloads.net/extensions/622.html 这个插件 可以直接在Google商店 直接搜索到，注册账号之后 就可以使用 在注册账号的时候需要 通过VPN 到外网注册 总结 使用FB账号时，尽量不要切换IP，IP切换频繁的话会被封号，我完成项目之前被封了4个帐号 emmm 这一点的话推荐还是找有固定IP的VPN。 回头再看也没有比较麻烦的地方，但是对于FB开发者账号的应用还是知之甚少。但就授权来说，主要还是跳转授权的地址要确定配置成为能访问到FB。这一点上我们运维很厉害了，哈哈。 代码部分后面存放在百度云盘再贴出来。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FaceBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 搭建过程]]></title>
    <url>%2F2017%2FHexo-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这里记录是从 配置环境之后的记录 有需要环境配置的朋友自行百度。 首先第一步 要创建自己的GitHub账号 传送门 GitHub 第二步 使用自己的GitHub账号建库 库名格式必须为 GitHub账号.github.io 在创建库时要注意最后这一个选项 要打勾，否者后面将不能添加绑定域名 第三步 进入库的设置将自己的域名添加进去 第四步 将自己的域名解析到 GitHub 的IP 注意这里的Ip有可能会产生变化从而导致解析失效。 常用的 HEXO 命令 123456789hexo n "新文章名字" # 新建文章hexo g # 清除 public 文件有时清除不干净导致无法更新博客内容，这是可以手动删除 public 文件夹hexo s # 开启本地服务hexo d # 将本地文件上载更新到Git库中hexo 文件中 代码标签一行必须从行首开始否者不会生效导致原样输出 总结 整体搭建还算简单主要是一些配置文件不熟悉，这篇博文后续跟上 环境搭建 的步骤 现在还欠缺的有博文评论功能 也在后续跟上吧]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇总]]></title>
    <url>%2F2017%2F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake [title] [] [url] [link text]1code snippet 样例普通的代码块 1alert('Hello World!'); alert(‘Hello World!’);指定语言 php输出123$arr = array('23','kk'=&gt;3);implode(',',$arr);[rectangle setX: 10 y: 10 width: 20 height: 20]; 1[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20];附加说明 Array.map1array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg])附加说明和网址 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] .compactUnderscore.js .compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 查找文章编写的标签背景图片更换 Ingrid Michaeson百度检测添加 正确认识和使用 标签以及分类]]></content>
  </entry>
</search>
